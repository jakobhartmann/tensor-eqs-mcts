/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals, improper_ctypes)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type string = [u64; 4usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair {
            pub _address: u8,
        }
        pub type pair_first_type = u8;
        pub type pair_second_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = u64;
        pub type allocator_difference_type = u64;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        pub type allocator_value_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type ofstream = [u64; 64usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map {
            pub _address: u8,
        }
        pub type map_key_type = u8;
        pub type map_mapped_type = u8;
        pub type map_value_type = u8;
        pub type map_key_compare = u8;
        pub type map_allocator_type = u8;
        pub type map__Alloc_value_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map_value_compare {
            pub _address: u8,
        }
        pub type map__Pair_alloc_type = u8;
        pub type map__Rep_type = u8;
        pub type map__Alloc_traits = u8;
        pub type map_pointer = u8;
        pub type map_const_pointer = u8;
        pub type map_reference = u8;
        pub type map_const_reference = u8;
        pub type map_iterator = u8;
        pub type map_const_iterator = u8;
        pub type map_size_type = u8;
        pub type map_difference_type = u8;
        pub type map_reverse_iterator = u8;
        pub type map_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector__Alloc_value_type = u8;
        pub type vector__Base = u8;
        pub type vector__Tp_alloc_type = u8;
        pub type vector__Alloc_traits = u8;
        pub type vector_value_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_size_type = u64;
        pub type vector_difference_type = u64;
        pub type vector_allocator_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct set {
            pub _address: u8,
        }
        pub type set__Alloc_value_type = u8;
        pub type set_key_type = u8;
        pub type set_value_type = u8;
        pub type set_key_compare = u8;
        pub type set_value_compare = u8;
        pub type set_allocator_type = u8;
        pub type set__Key_alloc_type = u8;
        pub type set__Rep_type = u8;
        pub type set__Alloc_traits = u8;
        pub type set_pointer = u8;
        pub type set_const_pointer = u8;
        pub type set_reference = u8;
        pub type set_const_reference = u8;
        pub type set_iterator = u8;
        pub type set_const_iterator = u8;
        pub type set_reverse_iterator = u8;
        pub type set_const_reverse_iterator = u8;
        pub type set_size_type = u8;
        pub type set_difference_type = u8;
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type size_t = ::std::os::raw::c_ulong;
    pub mod taso {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type DATATYPE = f32;
        pub const OpType_OP_INPUT: root::taso::OpType = 0;
        pub const OpType_OP_WEIGHT: root::taso::OpType = 1;
        pub const OpType_OP_ANY: root::taso::OpType = 2;
        pub const OpType_OP_CONV2D: root::taso::OpType = 3;
        pub const OpType_OP_DROPOUT: root::taso::OpType = 4;
        pub const OpType_OP_LINEAR: root::taso::OpType = 5;
        pub const OpType_OP_POOL2D_MAX: root::taso::OpType = 6;
        pub const OpType_OP_POOL2D_AVG: root::taso::OpType = 7;
        pub const OpType_OP_RELU: root::taso::OpType = 8;
        pub const OpType_OP_SIGMOID: root::taso::OpType = 9;
        pub const OpType_OP_TANH: root::taso::OpType = 10;
        pub const OpType_OP_BATCHNORM: root::taso::OpType = 11;
        pub const OpType_OP_CONCAT: root::taso::OpType = 12;
        pub const OpType_OP_SPLIT: root::taso::OpType = 13;
        pub const OpType_OP_RESHAPE: root::taso::OpType = 14;
        pub const OpType_OP_TRANSPOSE: root::taso::OpType = 15;
        pub const OpType_OP_EW_ADD: root::taso::OpType = 16;
        pub const OpType_OP_EW_MUL: root::taso::OpType = 17;
        pub const OpType_OP_MATMUL: root::taso::OpType = 18;
        pub const OpType_OP_MUL: root::taso::OpType = 19;
        pub const OpType_OP_ENLARGE: root::taso::OpType = 20;
        pub const OpType_OP_MERGE_GCONV: root::taso::OpType = 21;
        pub const OpType_OP_CONSTANT_IMM: root::taso::OpType = 22;
        pub const OpType_OP_CONSTANT_ICONV: root::taso::OpType = 23;
        pub const OpType_OP_CONSTANT_ONE: root::taso::OpType = 24;
        pub const OpType_OP_CONSTANT_POOL: root::taso::OpType = 25;
        pub const OpType_OP_SQUEEZE: root::taso::OpType = 26;
        pub const OpType_OP_UNSQUEEZE: root::taso::OpType = 27;
        pub const OpType_OP_EW_SUB: root::taso::OpType = 28;
        pub const OpType_OP_EW_DIV: root::taso::OpType = 29;
        pub const OpType_OP_EW_EQUAL: root::taso::OpType = 30;
        pub const OpType_OP_EW_GREATER: root::taso::OpType = 31;
        pub const OpType_OP_EW_LESS: root::taso::OpType = 32;
        pub const OpType_OP_EW_MAX: root::taso::OpType = 33;
        pub const OpType_OP_EW_MIN: root::taso::OpType = 34;
        pub const OpType_OP_REDUCE_ARGMAX: root::taso::OpType = 35;
        pub const OpType_OP_REDUCE_ARGMIN: root::taso::OpType = 36;
        pub const OpType_OP_REDUCE_MAX: root::taso::OpType = 37;
        pub const OpType_OP_REDUCE_MEAN: root::taso::OpType = 38;
        pub const OpType_OP_REDUCE_MIN: root::taso::OpType = 39;
        pub const OpType_OP_REDUCE_PROD: root::taso::OpType = 40;
        pub const OpType_OP_REDUCE_SUM: root::taso::OpType = 41;
        pub const OpType_OP_PAD: root::taso::OpType = 42;
        pub const OpType_OP_SHAPE: root::taso::OpType = 43;
        pub const OpType_OP_SIZE: root::taso::OpType = 44;
        pub const OpType_OP_TOPK: root::taso::OpType = 45;
        pub const OpType_OP_WHERE: root::taso::OpType = 46;
        pub const OpType_OP_CEIL: root::taso::OpType = 47;
        pub const OpType_OP_CAST: root::taso::OpType = 48;
        pub const OpType_OP_EXP: root::taso::OpType = 49;
        pub const OpType_OP_ROUND: root::taso::OpType = 50;
        pub const OpType_OP_LOG: root::taso::OpType = 51;
        pub const OpType_OP_LOGICAL_NOT: root::taso::OpType = 52;
        pub const OpType_OP_SQRT: root::taso::OpType = 53;
        pub const OpType_OP_LEAKYRELU: root::taso::OpType = 54;
        pub const OpType_OP_SLICE: root::taso::OpType = 55;
        pub const OpType_OP_RESIZE: root::taso::OpType = 56;
        pub type OpType = u32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Op {
            pub guid: root::size_t,
            pub ptr: *mut root::taso::OpBase,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso2Op10INVALID_OPE"]
            pub static Op_INVALID_OP: root::taso::Op;
        }
        #[test]
        fn bindgen_test_layout_Op() {
            assert_eq!(
                ::std::mem::size_of::<Op>(),
                16usize,
                concat!("Size of: ", stringify!(Op))
            );
            assert_eq!(
                ::std::mem::align_of::<Op>(),
                8usize,
                concat!("Alignment of ", stringify!(Op))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Op>())).guid as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(Op), "::", stringify!(guid))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Op>())).ptr as *const _ as usize },
                8usize,
                concat!("Offset of field: ", stringify!(Op), "::", stringify!(ptr))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso2Op12op_to_stringB5cxx11EPKNS_6OpBaseE"]
            pub fn Op_op_to_string(
                this: *mut root::taso::Op,
                ptr: *const root::taso::OpBase,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso2Op9to_stringB5cxx11Ev"]
            pub fn Op_to_string(this: *mut root::taso::Op) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso2OpC1Ev"]
            pub fn Op_Op(this: *mut root::taso::Op);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso2OpC1EmPNS_6OpBaseE"]
            pub fn Op_Op1(
                this: *mut root::taso::Op,
                _guid: root::size_t,
                _ptr: *mut root::taso::OpBase,
            );
        }
        impl Op {
            #[inline]
            pub unsafe fn op_to_string(
                &mut self,
                ptr: *const root::taso::OpBase,
            ) -> root::std::string {
                Op_op_to_string(self, ptr)
            }
            #[inline]
            pub unsafe fn to_string(&mut self) -> root::std::string {
                Op_to_string(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Op_Op(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(_guid: root::size_t, _ptr: *mut root::taso::OpBase) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Op_Op1(__bindgen_tmp.as_mut_ptr(), _guid, _ptr);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Edge {
            pub srcOp: root::taso::Op,
            pub dstOp: root::taso::Op,
            pub srcIdx: ::std::os::raw::c_int,
            pub dstIdx: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_Edge() {
            assert_eq!(
                ::std::mem::size_of::<Edge>(),
                40usize,
                concat!("Size of: ", stringify!(Edge))
            );
            assert_eq!(
                ::std::mem::align_of::<Edge>(),
                8usize,
                concat!("Alignment of ", stringify!(Edge))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Edge>())).srcOp as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Edge),
                    "::",
                    stringify!(srcOp)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Edge>())).dstOp as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Edge),
                    "::",
                    stringify!(dstOp)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Edge>())).srcIdx as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Edge),
                    "::",
                    stringify!(srcIdx)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Edge>())).dstIdx as *const _ as usize },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Edge),
                    "::",
                    stringify!(dstIdx)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4EdgeC1Ev"]
            pub fn Edge_Edge(this: *mut root::taso::Edge);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4EdgeC1ENS_2OpES1_ii"]
            pub fn Edge_Edge1(
                this: *mut root::taso::Edge,
                _srcOp: root::taso::Op,
                _dstOp: root::taso::Op,
                _srcIdx: ::std::os::raw::c_int,
                _dstIdx: ::std::os::raw::c_int,
            );
        }
        impl Edge {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Edge_Edge(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                _srcOp: root::taso::Op,
                _dstOp: root::taso::Op,
                _srcIdx: ::std::os::raw::c_int,
                _dstIdx: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Edge_Edge1(__bindgen_tmp.as_mut_ptr(), _srcOp, _dstOp, _srcIdx, _dstIdx);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EdgeCompare {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_EdgeCompare() {
            assert_eq!(
                ::std::mem::size_of::<EdgeCompare>(),
                1usize,
                concat!("Size of: ", stringify!(EdgeCompare))
            );
            assert_eq!(
                ::std::mem::align_of::<EdgeCompare>(),
                1usize,
                concat!("Alignment of ", stringify!(EdgeCompare))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OpCompare {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_OpCompare() {
            assert_eq!(
                ::std::mem::size_of::<OpCompare>(),
                1usize,
                concat!("Size of: ", stringify!(OpCompare))
            );
            assert_eq!(
                ::std::mem::align_of::<OpCompare>(),
                1usize,
                concat!("Alignment of ", stringify!(OpCompare))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SplitInfo {
            pub num: ::std::os::raw::c_int,
            pub pos: [::std::os::raw::c_int; 32usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9SplitInfo8NO_SPLITE"]
            pub static SplitInfo_NO_SPLIT: root::taso::SplitInfo;
        }
        #[test]
        fn bindgen_test_layout_SplitInfo() {
            assert_eq!(
                ::std::mem::size_of::<SplitInfo>(),
                132usize,
                concat!("Size of: ", stringify!(SplitInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<SplitInfo>(),
                4usize,
                concat!("Alignment of ", stringify!(SplitInfo))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SplitInfo>())).num as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SplitInfo),
                    "::",
                    stringify!(num)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SplitInfo>())).pos as *const _ as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SplitInfo),
                    "::",
                    stringify!(pos)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9SplitInfo5mergeEiRKS0_"]
            pub fn SplitInfo_merge(
                this: *mut root::taso::SplitInfo,
                offset: ::std::os::raw::c_int,
                next: *const root::taso::SplitInfo,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9SplitInfo6divideERS0_S1_Ri"]
            pub fn SplitInfo_divide(
                this: *mut root::taso::SplitInfo,
                left: *mut root::taso::SplitInfo,
                right: *mut root::taso::SplitInfo,
                mid: *mut ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9SplitInfo7combineERKS0_"]
            pub fn SplitInfo_combine(
                this: *mut root::taso::SplitInfo,
                next: *const root::taso::SplitInfo,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK4taso9SplitInfo9serializeEPiRi"]
            pub fn SplitInfo_serialize(
                this: *const root::taso::SplitInfo,
                keys: *mut ::std::os::raw::c_int,
                idx: *mut ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9SplitInfoC1Ev"]
            pub fn SplitInfo_SplitInfo(this: *mut root::taso::SplitInfo);
        }
        impl SplitInfo {
            #[inline]
            pub unsafe fn merge(
                &mut self,
                offset: ::std::os::raw::c_int,
                next: *const root::taso::SplitInfo,
            ) {
                SplitInfo_merge(self, offset, next)
            }
            #[inline]
            pub unsafe fn divide(
                &mut self,
                left: *mut root::taso::SplitInfo,
                right: *mut root::taso::SplitInfo,
                mid: *mut ::std::os::raw::c_int,
            ) {
                SplitInfo_divide(self, left, right, mid)
            }
            #[inline]
            pub unsafe fn combine(&mut self, next: *const root::taso::SplitInfo) {
                SplitInfo_combine(self, next)
            }
            #[inline]
            pub unsafe fn serialize(
                &self,
                keys: *mut ::std::os::raw::c_int,
                idx: *mut ::std::os::raw::c_int,
            ) {
                SplitInfo_serialize(self, keys, idx)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SplitInfo_SplitInfo(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Tensor {
            pub numDim: ::std::os::raw::c_int,
            pub dim: [::std::os::raw::c_int; 8usize],
            pub stride: [::std::os::raw::c_int; 8usize],
            pub idx: ::std::os::raw::c_int,
            pub op: root::taso::Op,
            pub data_ptr: *mut ::std::os::raw::c_void,
            pub split: [root::taso::SplitInfo; 8usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Tensor14MAX_KEY_LENGTHE"]
            pub static Tensor_MAX_KEY_LENGTH: ::std::os::raw::c_int;
        }
        pub const Tensor_MAGIC_NUMBER: ::std::os::raw::c_int = 23333;
        #[test]
        fn bindgen_test_layout_Tensor() {
            assert_eq!(
                ::std::mem::size_of::<Tensor>(),
                1152usize,
                concat!("Size of: ", stringify!(Tensor))
            );
            assert_eq!(
                ::std::mem::align_of::<Tensor>(),
                8usize,
                concat!("Alignment of ", stringify!(Tensor))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Tensor>())).numDim as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Tensor),
                    "::",
                    stringify!(numDim)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Tensor>())).dim as *const _ as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Tensor),
                    "::",
                    stringify!(dim)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Tensor>())).stride as *const _ as usize },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Tensor),
                    "::",
                    stringify!(stride)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Tensor>())).idx as *const _ as usize },
                68usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Tensor),
                    "::",
                    stringify!(idx)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Tensor>())).op as *const _ as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Tensor),
                    "::",
                    stringify!(op)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Tensor>())).data_ptr as *const _ as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Tensor),
                    "::",
                    stringify!(data_ptr)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Tensor>())).split as *const _ as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Tensor),
                    "::",
                    stringify!(split)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK4taso6Tensor6volumeEv"]
            pub fn Tensor_volume(this: *const root::taso::Tensor) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Tensor9to_stringENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn Tensor_to_string(
                this: *mut root::taso::Tensor,
                name: root::std::string,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK4taso6Tensor9serializeEPiRi"]
            pub fn Tensor_serialize(
                this: *const root::taso::Tensor,
                keys: *mut ::std::os::raw::c_int,
                idx: *mut ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK4taso6Tensor27has_same_shape_stride_splitERKS0_"]
            pub fn Tensor_has_same_shape_stride_split(
                this: *const root::taso::Tensor,
                tensor: *const root::taso::Tensor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK4taso6Tensor14default_layoutEv"]
            pub fn Tensor_default_layout(this: *const root::taso::Tensor) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6TensorC1Ev"]
            pub fn Tensor_Tensor(this: *mut root::taso::Tensor);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6TensorC1EiPKimPf"]
            pub fn Tensor_Tensor1(
                this: *mut root::taso::Tensor,
                ndim: ::std::os::raw::c_int,
                dims: *const ::std::os::raw::c_int,
                guid: root::size_t,
                data: *mut root::taso::DATATYPE,
            );
        }
        impl Tensor {
            #[inline]
            pub unsafe fn volume(&self) -> ::std::os::raw::c_int {
                Tensor_volume(self)
            }
            #[inline]
            pub unsafe fn to_string(&mut self, name: root::std::string) -> root::std::string {
                Tensor_to_string(self, name)
            }
            #[inline]
            pub unsafe fn serialize(
                &self,
                keys: *mut ::std::os::raw::c_int,
                idx: *mut ::std::os::raw::c_int,
            ) {
                Tensor_serialize(self, keys, idx)
            }
            #[inline]
            pub unsafe fn has_same_shape_stride_split(
                &self,
                tensor: *const root::taso::Tensor,
            ) -> bool {
                Tensor_has_same_shape_stride_split(self, tensor)
            }
            #[inline]
            pub unsafe fn default_layout(&self) -> bool {
                Tensor_default_layout(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Tensor_Tensor(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                ndim: ::std::os::raw::c_int,
                dims: *const ::std::os::raw::c_int,
                guid: root::size_t,
                data: *mut root::taso::DATATYPE,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Tensor_Tensor1(__bindgen_tmp.as_mut_ptr(), ndim, dims, guid, data);
                __bindgen_tmp.assume_init()
            }
        }
        pub type TensorHandle = *mut root::taso::Tensor;
        pub const DataType_DT_FLOAT: root::taso::DataType = 111;
        pub const DataType_DT_DOUBLE: root::taso::DataType = 222;
        pub const DataType_DT_HALF: root::taso::DataType = 333;
        pub const DataType_DT_INT8: root::taso::DataType = 444;
        pub const DataType_DT_UINT8: root::taso::DataType = 555;
        pub const DataType_DT_INT32: root::taso::DataType = 666;
        pub const DataType_DT_INT64: root::taso::DataType = 777;
        pub const DataType_DT_BOOL: root::taso::DataType = 888;
        pub type DataType = u32;
        pub const PMParameter_PM_OP_TYPE: root::taso::PMParameter = 0;
        pub const PMParameter_PM_NUM_INPUTS: root::taso::PMParameter = 1;
        pub const PMParameter_PM_NUM_OUTPUTS: root::taso::PMParameter = 2;
        pub const PMParameter_PM_GROUP: root::taso::PMParameter = 3;
        pub const PMParameter_PM_KERNEL_H: root::taso::PMParameter = 4;
        pub const PMParameter_PM_KERNEL_W: root::taso::PMParameter = 5;
        pub const PMParameter_PM_STRIDE_H: root::taso::PMParameter = 6;
        pub const PMParameter_PM_STRIDE_W: root::taso::PMParameter = 7;
        pub const PMParameter_PM_PAD: root::taso::PMParameter = 8;
        pub const PMParameter_PM_ACTI: root::taso::PMParameter = 9;
        pub const PMParameter_PM_NUMDIM: root::taso::PMParameter = 10;
        pub const PMParameter_PM_AXIS: root::taso::PMParameter = 11;
        pub const PMParameter_PM_PERM: root::taso::PMParameter = 12;
        pub const PMParameter_PM_OUTSHUFFLE: root::taso::PMParameter = 13;
        pub const PMParameter_PM_MERGE_GCONV_COUNT: root::taso::PMParameter = 14;
        pub const PMParameter_PM_AXES: root::taso::PMParameter = 15;
        pub const PMParameter_PM_KEEP_DIMS: root::taso::PMParameter = 16;
        pub type PMParameter = u32;
        pub const TNParameter_IN_0: root::taso::TNParameter = 100;
        pub const TNParameter_IN_1: root::taso::TNParameter = 101;
        pub const TNParameter_IN_2: root::taso::TNParameter = 102;
        pub const TNParameter_IN_3: root::taso::TNParameter = 103;
        pub const TNParameter_IN_4: root::taso::TNParameter = 104;
        pub const TNParameter_IN_5: root::taso::TNParameter = 105;
        pub const TNParameter_OU_0: root::taso::TNParameter = 200;
        pub const TNParameter_OU_1: root::taso::TNParameter = 201;
        pub const TNParameter_OU_2: root::taso::TNParameter = 202;
        pub const TNParameter_OU_3: root::taso::TNParameter = 203;
        pub const TNParameter_OU_4: root::taso::TNParameter = 204;
        pub const TNParameter_OU_5: root::taso::TNParameter = 205;
        pub type TNParameter = u32;
        pub const DIMParameter_DIM_0: root::taso::DIMParameter = 300;
        pub const DIMParameter_DIM_1: root::taso::DIMParameter = 301;
        pub const DIMParameter_DIM_2: root::taso::DIMParameter = 302;
        pub const DIMParameter_DIM_3: root::taso::DIMParameter = 303;
        pub const DIMParameter_DIM_ND: root::taso::DIMParameter = 310;
        pub type DIMParameter = u32;
        pub const ActiMode_AC_MODE_NONE: root::taso::ActiMode = 0;
        pub const ActiMode_AC_MODE_SIGMOID: root::taso::ActiMode = 1;
        pub const ActiMode_AC_MODE_RELU: root::taso::ActiMode = 2;
        pub const ActiMode_AC_MODE_TANH: root::taso::ActiMode = 3;
        pub type ActiMode = u32;
        pub const PaddingMode_PD_MODE_SAME: root::taso::PaddingMode = 0;
        pub const PaddingMode_PD_MODE_VALID: root::taso::PaddingMode = 1;
        pub type PaddingMode = u32;
        #[repr(C)]
        pub struct OpBase__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OpBase {
            pub vtable_: *const OpBase__bindgen_vtable,
            pub inputs: [root::taso::Tensor; 6usize],
            pub outputs: [root::taso::Tensor; 6usize],
            pub numInputs: ::std::os::raw::c_int,
            pub numOutputs: ::std::os::raw::c_int,
            pub model: *mut root::taso::Model,
            pub type_: root::taso::OpType,
            pub runtime: f32,
        }
        #[test]
        fn bindgen_test_layout_OpBase() {
            assert_eq!(
                ::std::mem::size_of::<OpBase>(),
                13856usize,
                concat!("Size of: ", stringify!(OpBase))
            );
            assert_eq!(
                ::std::mem::align_of::<OpBase>(),
                8usize,
                concat!("Alignment of ", stringify!(OpBase))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).inputs as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(inputs)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).outputs as *const _ as usize },
                6920usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(outputs)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).numInputs as *const _ as usize },
                13832usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(numInputs)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).numOutputs as *const _ as usize },
                13836usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(numOutputs)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).model as *const _ as usize },
                13840usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(model)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).type_ as *const _ as usize },
                13848usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(type_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).runtime as *const _ as usize },
                13852usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(runtime)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBaseC2EPNS_5ModelENS_6OpTypeE"]
            pub fn OpBase_OpBase(
                this: *mut root::taso::OpBase,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBaseC2ERKNS_6TensorEPNS_5ModelENS_6OpTypeE"]
            pub fn OpBase_OpBase1(
                this: *mut root::taso::OpBase,
                input: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBaseC2ERKNS_6TensorES3_PNS_5ModelENS_6OpTypeE"]
            pub fn OpBase_OpBase2(
                this: *mut root::taso::OpBase,
                input0: *const root::taso::Tensor,
                input1: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBaseC2ERKNS_6TensorES3_S3_PNS_5ModelENS_6OpTypeE"]
            pub fn OpBase_OpBase3(
                this: *mut root::taso::OpBase,
                input0: *const root::taso::Tensor,
                input1: *const root::taso::Tensor,
                input2: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBaseC2ERKNS_6TensorES3_S3_S3_S3_PNS_5ModelENS_6OpTypeE"]
            pub fn OpBase_OpBase4(
                this: *mut root::taso::OpBase,
                input0: *const root::taso::Tensor,
                input1: *const root::taso::Tensor,
                input2: *const root::taso::Tensor,
                input3: *const root::taso::Tensor,
                input4: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBaseC2EiPNS_6TensorEPNS_5ModelENS_6OpTypeE"]
            pub fn OpBase_OpBase5(
                this: *mut root::taso::OpBase,
                n: ::std::os::raw::c_int,
                inputs: *mut root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            );
        }
        impl OpBase {
            #[inline]
            pub unsafe fn new(_model: *mut root::taso::Model, _type: root::taso::OpType) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OpBase_OpBase(__bindgen_tmp.as_mut_ptr(), _model, _type);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                input: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OpBase_OpBase1(__bindgen_tmp.as_mut_ptr(), input, _model, _type);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(
                input0: *const root::taso::Tensor,
                input1: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OpBase_OpBase2(__bindgen_tmp.as_mut_ptr(), input0, input1, _model, _type);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new3(
                input0: *const root::taso::Tensor,
                input1: *const root::taso::Tensor,
                input2: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OpBase_OpBase3(
                    __bindgen_tmp.as_mut_ptr(),
                    input0,
                    input1,
                    input2,
                    _model,
                    _type,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new4(
                input0: *const root::taso::Tensor,
                input1: *const root::taso::Tensor,
                input2: *const root::taso::Tensor,
                input3: *const root::taso::Tensor,
                input4: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OpBase_OpBase4(
                    __bindgen_tmp.as_mut_ptr(),
                    input0,
                    input1,
                    input2,
                    input3,
                    input4,
                    _model,
                    _type,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new5(
                n: ::std::os::raw::c_int,
                inputs: *mut root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OpBase_OpBase5(__bindgen_tmp.as_mut_ptr(), n, inputs, _model, _type);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBase19get_input_parameterENS_11TNParameterENS_12DIMParameterEPi"]
            pub fn OpBase_get_input_parameter(
                this: *mut ::std::os::raw::c_void,
                arg1: root::taso::TNParameter,
                arg2: root::taso::DIMParameter,
                arg3: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBase17get_int_parameterENS_11PMParameterEPi"]
            pub fn OpBase_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                arg1: root::taso::PMParameter,
                arg2: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Clone)]
        pub struct Graph {
            pub model: *mut root::taso::Model,
            pub totalCost: f32,
            pub inEdges: [u64; 6usize],
            pub outEdges: [u64; 6usize],
            pub subst_history: [u64; 3usize],
        }
        unsafe impl Send for Graph {}
        unsafe impl Sync for Graph {}
        #[repr(C)]
        #[derive(Debug)]
        pub struct Graph_GraphSubst {
            pub srcOps: [u64; 3usize],
            pub dstOps: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Graph_GraphSubst() {
            assert_eq!(
                ::std::mem::size_of::<Graph_GraphSubst>(),
                48usize,
                concat!("Size of: ", stringify!(Graph_GraphSubst))
            );
            assert_eq!(
                ::std::mem::align_of::<Graph_GraphSubst>(),
                8usize,
                concat!("Alignment of ", stringify!(Graph_GraphSubst))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph_GraphSubst>())).srcOps as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph_GraphSubst),
                    "::",
                    stringify!(srcOps)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph_GraphSubst>())).dstOps as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph_GraphSubst),
                    "::",
                    stringify!(dstOps)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_Graph() {
            assert_eq!(
                ::std::mem::size_of::<Graph>(),
                136usize,
                concat!("Size of: ", stringify!(Graph))
            );
            assert_eq!(
                ::std::mem::align_of::<Graph>(),
                8usize,
                concat!("Alignment of ", stringify!(Graph))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph>())).model as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph),
                    "::",
                    stringify!(model)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph>())).totalCost as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph),
                    "::",
                    stringify!(totalCost)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph>())).inEdges as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph),
                    "::",
                    stringify!(inEdges)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph>())).outEdges as *const _ as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph),
                    "::",
                    stringify!(outEdges)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph>())).subst_history as *const _ as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph),
                    "::",
                    stringify!(subst_history)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph9new_inputEiPKi"]
            pub fn Graph_new_input(
                this: *mut root::taso::Graph,
                dim: ::std::os::raw::c_int,
                dims: *const ::std::os::raw::c_int,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10new_weightEiPKiPKf"]
            pub fn Graph_new_weight(
                this: *mut root::taso::Graph,
                dim: ::std::os::raw::c_int,
                dims: *const ::std::os::raw::c_int,
                data: *const root::taso::DATATYPE,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10new_weightERKNS_6TensorE"]
            pub fn Graph_new_weight1(
                this: *mut root::taso::Graph,
                input: *const root::taso::Tensor,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph8add_edgeENS_2OpES1_ii"]
            pub fn Graph_add_edge(
                this: *mut root::taso::Graph,
                srcOp: root::taso::Op,
                dstOp: root::taso::Op,
                srcIdx: ::std::os::raw::c_int,
                dstIdx: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11remove_edgeENS_4EdgeE"]
            pub fn Graph_remove_edge(this: *mut root::taso::Graph, e: root::taso::Edge);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph8has_edgeENS_2OpES1_ii"]
            pub fn Graph_has_edge(
                this: *mut root::taso::Graph,
                srcOp: root::taso::Op,
                dstOp: root::taso::Op,
                srcIdx: ::std::os::raw::c_int,
                dstIdx: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph12replace_nodeENS_2OpES1_"]
            pub fn Graph_replace_node(
                this: *mut root::taso::Graph,
                oldOp: root::taso::Op,
                newOp: root::taso::Op,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11remove_nodeENS_2OpE"]
            pub fn Graph_remove_node(this: *mut root::taso::Graph, oldOp: root::taso::Op);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph18export_to_file_rawEPc"]
            pub fn Graph_export_to_file_raw(
                this: *mut root::taso::Graph,
                file_name: *mut ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph14export_to_fileENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn Graph_export_to_file(this: *mut root::taso::Graph, file_name: root::std::string);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph12group_conv2dEiPNS_6TensorEiiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Graph_group_conv2d(
                this: *mut root::taso::Graph,
                groups: ::std::os::raw::c_int,
                _input: root::taso::TensorHandle,
                _outputC: ::std::os::raw::c_int,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph9batchnormEPNS_6TensorES2_S2_S2_S2_"]
            pub fn Graph_batchnorm(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _scale: root::taso::TensorHandle,
                _bias: root::taso::TensorHandle,
                _mean: root::taso::TensorHandle,
                _var: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4castEPNS_6TensorENS_8DataTypeE"]
            pub fn Graph_cast(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _datatype: root::taso::DataType,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4ceilEPNS_6TensorE"]
            pub fn Graph_ceil(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph6concatEiiPKPNS_6TensorE"]
            pub fn Graph_concat(
                this: *mut root::taso::Graph,
                axis: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
                _inputs: *const root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph8constantEiPiNS_6OpTypeE"]
            pub fn Graph_constant(
                this: *mut root::taso::Graph,
                ndim: ::std::os::raw::c_int,
                dims: *mut ::std::os::raw::c_int,
                _type: root::taso::OpType,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph6conv2dEPNS_6TensorEiiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Graph_conv2d(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _outputC: ::std::os::raw::c_int,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph6conv2dEPNS_6TensorES2_iiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Graph_conv2d1(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _weight: root::taso::TensorHandle,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph7dropoutEPNS_6TensorE"]
            pub fn Graph_dropout(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph7elementENS_6OpTypeEPNS_6TensorES3_"]
            pub fn Graph_element(
                this: *mut root::taso::Graph,
                type_: root::taso::OpType,
                _t1: root::taso::TensorHandle,
                _t2: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph17elementwise_unaryEPNS_6TensorENS_6OpTypeE"]
            pub fn Graph_elementwise_unary(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _type: root::taso::OpType,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph7enlargeEPNS_6TensorES2_"]
            pub fn Graph_enlarge(
                this: *mut root::taso::Graph,
                _w1: root::taso::TensorHandle,
                _w2: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph3expEPNS_6TensorE"]
            pub fn Graph_exp(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph2fcEPNS_6TensorEiNS_8ActiModeE"]
            pub fn Graph_fc(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _outputC: ::std::os::raw::c_int,
                _actiMode: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph9leakyreluEPNS_6TensorEfb"]
            pub fn Graph_leakyrelu(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _alpha: f32,
                _inplace: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph3logEPNS_6TensorE"]
            pub fn Graph_log(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11logical_notEPNS_6TensorE"]
            pub fn Graph_logical_not(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph6matmulEPNS_6TensorES2_NS_8ActiModeE"]
            pub fn Graph_matmul(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _weight: root::taso::TensorHandle,
                _actiMode: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11merge_gconvEPNS_6TensorEi"]
            pub fn Graph_merge_gconv(
                this: *mut root::taso::Graph,
                _weight: root::taso::TensorHandle,
                count: ::std::os::raw::c_int,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph3mulEPNS_6TensorES2_"]
            pub fn Graph_mul(
                this: *mut root::taso::Graph,
                _x: root::taso::TensorHandle,
                _y: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph3padEPNS_6TensorERKSt6vectorIiSaIiEES7_f"]
            pub fn Graph_pad(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10pool2d_maxEPNS_6TensorEiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Graph_pool2d_max(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10pool2d_avgEPNS_6TensorEiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Graph_pool2d_avg(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph6reduceEPNS_6TensorENS_6OpTypeERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _type: root::taso::OpType,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph13reduce_argmaxEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_argmax(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph13reduce_argminEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_argmin(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10reduce_maxEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_max(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11reduce_meanEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_mean(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10reduce_minEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_min(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11reduce_prodEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_prod(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10reduce_sumEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_sum(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4reluEPNS_6TensorEb"]
            pub fn Graph_relu(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _inPlace: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph7reshapeEPNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Graph_reshape(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _shape: *const [u64; 3usize],
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph6resizeEPNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Graph_resize(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _shape: *const [u64; 3usize],
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph5roundEPNS_6TensorE"]
            pub fn Graph_round(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph5shapeEPNS_6TensorENS_6OpTypeE"]
            pub fn Graph_shape(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _type: root::taso::OpType,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph5sliceEPNS_6TensorERKSt6vectorIiSaIiEES7_S7_S7_"]
            pub fn Graph_slice(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph7sigmoidEPNS_6TensorEb"]
            pub fn Graph_sigmoid(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _inPlace: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph5splitEPNS_6TensorEiRKSt6vectorIiSaIiEEPS2_"]
            pub fn Graph_split(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
                _outputs: *mut root::taso::TensorHandle,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11split_equalEPNS_6TensorEiiPS2_"]
            pub fn Graph_split_equal(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _axis: ::std::os::raw::c_int,
                _num: ::std::os::raw::c_int,
                _outputs: *mut root::taso::TensorHandle,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4sqrtEPNS_6TensorE"]
            pub fn Graph_sqrt(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph7squeezeEPNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Graph_squeeze(
                this: *mut root::taso::Graph,
                input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph9transposeEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_transpose(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _perm: *const [u64; 3usize],
                _shuffle: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4tanhEPNS_6TensorEb"]
            pub fn Graph_tanh(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _inPlace: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4topkEPNS_6TensorEiibbS2_"]
            pub fn Graph_topk(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
                outputs: *mut root::taso::Tensor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph9unsqueezeEPNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Graph_unsqueeze(
                this: *mut root::taso::Graph,
                input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph5whereEPNS_6TensorES2_S2_"]
            pub fn Graph_where(
                this: *mut root::taso::Graph,
                _cond: root::taso::TensorHandle,
                _x: root::taso::TensorHandle,
                _y: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph15find_op_or_failEm"]
            pub fn Graph_find_op_or_fail(
                this: *mut root::taso::Graph,
                guid: root::size_t,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph8optimizeEfib"]
            pub fn Graph_optimize(
                this: *mut root::taso::Graph,
                alpha: f32,
                budget: ::std::os::raw::c_int,
                print_subst: bool,
            ) -> *mut root::taso::Graph;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph18preprocess_weightsEv"]
            pub fn Graph_preprocess_weights(this: *mut root::taso::Graph)
                -> *mut root::taso::Graph;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph17get_operator_listEPNS_2OpEm"]
            pub fn Graph_get_operator_list(
                this: *mut root::taso::Graph,
                opList: *mut root::taso::Op,
                maxNumOps: root::size_t,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph15get_input_edgesEPNS_4EdgeEm"]
            pub fn Graph_get_input_edges(
                this: *mut root::taso::Graph,
                opList: *mut root::taso::Edge,
                guid: root::size_t,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph17get_operator_typeEm"]
            pub fn Graph_get_operator_type(
                this: *mut root::taso::Graph,
                guid: root::size_t,
            ) -> root::taso::OpType;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph21get_operator_int_attrEmNS_11PMParameterE"]
            pub fn Graph_get_operator_int_attr(
                this: *mut root::taso::Graph,
                guid: root::size_t,
                attr: root::taso::PMParameter,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph15get_num_outputsEm"]
            pub fn Graph_get_num_outputs(
                this: *mut root::taso::Graph,
                guid: root::size_t,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph14get_input_dimsEmPii"]
            pub fn Graph_get_input_dims(
                this: *mut root::taso::Graph,
                guid: root::size_t,
                dims: *mut ::std::os::raw::c_int,
                idx: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph16get_weight_valueEmPf"]
            pub fn Graph_get_weight_value(
                this: *mut root::taso::Graph,
                guid: root::size_t,
                value: *mut root::taso::DATATYPE,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph15get_output_dimsEmPii"]
            pub fn Graph_get_output_dims(
                this: *mut root::taso::Graph,
                guid: root::size_t,
                dims: *mut ::std::os::raw::c_int,
                idx: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph14get_split_lensEmPi"]
            pub fn Graph_get_split_lens(
                this: *mut root::taso::Graph,
                guid: root::size_t,
                lens: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph12num_in_edgesENS_2OpE"]
            pub fn Graph_num_in_edges(
                this: *mut root::taso::Graph,
                op: root::taso::Op,
            ) -> root::size_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph13num_out_edgesENS_2OpE"]
            pub fn Graph_num_out_edges(
                this: *mut root::taso::Graph,
                op: root::taso::Op,
            ) -> root::size_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4hashEv"]
            pub fn Graph_hash(this: *mut root::taso::Graph) -> root::size_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph5printEv"]
            pub fn Graph_print(this: *mut root::taso::Graph);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph17check_correctnessEv"]
            pub fn Graph_check_correctness(this: *mut root::taso::Graph) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph8has_loopEv"]
            pub fn Graph_has_loop(this: *mut root::taso::Graph) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10total_costEv"]
            pub fn Graph_total_cost(this: *mut root::taso::Graph) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph3runEv"]
            pub fn Graph_run(this: *mut root::taso::Graph) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11print_costsEv"]
            pub fn Graph_print_costs(this: *mut root::taso::Graph);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph18print_measurementsEv"]
            pub fn Graph_print_measurements(this: *mut root::taso::Graph);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph9export_opERSt14basic_ofstreamIcSt11char_traitsIcEERNS_2OpE"]
            pub fn Graph_export_op(
                this: *mut root::taso::Graph,
                file_stream: *mut root::std::ofstream,
                op: *mut root::taso::Op,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5GraphC1Ev"]
            pub fn Graph_Graph(this: *mut root::taso::Graph);
        }
        impl Graph {
            #[inline]
            pub unsafe fn new_input(
                &mut self,
                dim: ::std::os::raw::c_int,
                dims: *const ::std::os::raw::c_int,
            ) -> root::taso::TensorHandle {
                Graph_new_input(self, dim, dims)
            }
            #[inline]
            pub unsafe fn new_weight(
                &mut self,
                dim: ::std::os::raw::c_int,
                dims: *const ::std::os::raw::c_int,
                data: *const root::taso::DATATYPE,
            ) -> root::taso::TensorHandle {
                Graph_new_weight(self, dim, dims, data)
            }
            #[inline]
            pub unsafe fn new_weight1(
                &mut self,
                input: *const root::taso::Tensor,
            ) -> root::taso::TensorHandle {
                Graph_new_weight1(self, input)
            }
            #[inline]
            pub unsafe fn add_edge(
                &mut self,
                srcOp: root::taso::Op,
                dstOp: root::taso::Op,
                srcIdx: ::std::os::raw::c_int,
                dstIdx: ::std::os::raw::c_int,
            ) {
                Graph_add_edge(self, srcOp, dstOp, srcIdx, dstIdx)
            }
            #[inline]
            pub unsafe fn remove_edge(&mut self, e: root::taso::Edge) {
                Graph_remove_edge(self, e)
            }
            #[inline]
            pub unsafe fn has_edge(
                &mut self,
                srcOp: root::taso::Op,
                dstOp: root::taso::Op,
                srcIdx: ::std::os::raw::c_int,
                dstIdx: ::std::os::raw::c_int,
            ) -> bool {
                Graph_has_edge(self, srcOp, dstOp, srcIdx, dstIdx)
            }
            #[inline]
            pub unsafe fn replace_node(&mut self, oldOp: root::taso::Op, newOp: root::taso::Op) {
                Graph_replace_node(self, oldOp, newOp)
            }
            #[inline]
            pub unsafe fn remove_node(&mut self, oldOp: root::taso::Op) {
                Graph_remove_node(self, oldOp)
            }
            #[inline]
            pub unsafe fn export_to_file_raw(&mut self, file_name: *mut ::std::os::raw::c_char) {
                Graph_export_to_file_raw(self, file_name)
            }
            #[inline]
            pub unsafe fn export_to_file(&mut self, file_name: root::std::string) {
                Graph_export_to_file(self, file_name)
            }
            #[inline]
            pub unsafe fn group_conv2d(
                &mut self,
                groups: ::std::os::raw::c_int,
                _input: root::taso::TensorHandle,
                _outputC: ::std::os::raw::c_int,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_group_conv2d(
                    self,
                    groups,
                    _input,
                    _outputC,
                    _kernelH,
                    _kernelW,
                    _strideH,
                    strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn batchnorm(
                &mut self,
                _input: root::taso::TensorHandle,
                _scale: root::taso::TensorHandle,
                _bias: root::taso::TensorHandle,
                _mean: root::taso::TensorHandle,
                _var: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_batchnorm(self, _input, _scale, _bias, _mean, _var)
            }
            #[inline]
            pub unsafe fn cast(
                &mut self,
                _input: root::taso::TensorHandle,
                _datatype: root::taso::DataType,
            ) -> root::taso::TensorHandle {
                Graph_cast(self, _input, _datatype)
            }
            #[inline]
            pub unsafe fn ceil(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_ceil(self, _input)
            }
            #[inline]
            pub unsafe fn concat(
                &mut self,
                axis: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
                _inputs: *const root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_concat(self, axis, n, _inputs)
            }
            #[inline]
            pub unsafe fn constant(
                &mut self,
                ndim: ::std::os::raw::c_int,
                dims: *mut ::std::os::raw::c_int,
                _type: root::taso::OpType,
            ) -> root::taso::TensorHandle {
                Graph_constant(self, ndim, dims, _type)
            }
            #[inline]
            pub unsafe fn conv2d(
                &mut self,
                _input: root::taso::TensorHandle,
                _outputC: ::std::os::raw::c_int,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_conv2d(
                    self,
                    _input,
                    _outputC,
                    _kernelH,
                    _kernelW,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn conv2d1(
                &mut self,
                _input: root::taso::TensorHandle,
                _weight: root::taso::TensorHandle,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_conv2d1(
                    self,
                    _input,
                    _weight,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn dropout(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_dropout(self, _input)
            }
            #[inline]
            pub unsafe fn element(
                &mut self,
                type_: root::taso::OpType,
                _t1: root::taso::TensorHandle,
                _t2: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_element(self, type_, _t1, _t2)
            }
            #[inline]
            pub unsafe fn elementwise_unary(
                &mut self,
                _input: root::taso::TensorHandle,
                _type: root::taso::OpType,
            ) -> root::taso::TensorHandle {
                Graph_elementwise_unary(self, _input, _type)
            }
            #[inline]
            pub unsafe fn enlarge(
                &mut self,
                _w1: root::taso::TensorHandle,
                _w2: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_enlarge(self, _w1, _w2)
            }
            #[inline]
            pub unsafe fn exp(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_exp(self, _input)
            }
            #[inline]
            pub unsafe fn fc(
                &mut self,
                _input: root::taso::TensorHandle,
                _outputC: ::std::os::raw::c_int,
                _actiMode: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_fc(self, _input, _outputC, _actiMode)
            }
            #[inline]
            pub unsafe fn leakyrelu(
                &mut self,
                _input: root::taso::TensorHandle,
                _alpha: f32,
                _inplace: bool,
            ) -> root::taso::TensorHandle {
                Graph_leakyrelu(self, _input, _alpha, _inplace)
            }
            #[inline]
            pub unsafe fn log(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_log(self, _input)
            }
            #[inline]
            pub unsafe fn logical_not(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_logical_not(self, _input)
            }
            #[inline]
            pub unsafe fn matmul(
                &mut self,
                _input: root::taso::TensorHandle,
                _weight: root::taso::TensorHandle,
                _actiMode: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_matmul(self, _input, _weight, _actiMode)
            }
            #[inline]
            pub unsafe fn merge_gconv(
                &mut self,
                _weight: root::taso::TensorHandle,
                count: ::std::os::raw::c_int,
            ) -> root::taso::TensorHandle {
                Graph_merge_gconv(self, _weight, count)
            }
            #[inline]
            pub unsafe fn mul(
                &mut self,
                _x: root::taso::TensorHandle,
                _y: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_mul(self, _x, _y)
            }
            #[inline]
            pub unsafe fn pad(
                &mut self,
                _input: root::taso::TensorHandle,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            ) -> root::taso::TensorHandle {
                Graph_pad(self, _input, _pad_before, _pad_after, _pad_value)
            }
            #[inline]
            pub unsafe fn pool2d_max(
                &mut self,
                _input: root::taso::TensorHandle,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_pool2d_max(
                    self,
                    _input,
                    _kernelH,
                    _kernelW,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn pool2d_avg(
                &mut self,
                _input: root::taso::TensorHandle,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_pool2d_avg(
                    self,
                    _input,
                    _kernelH,
                    _kernelW,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn reduce(
                &mut self,
                _input: root::taso::TensorHandle,
                _type: root::taso::OpType,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce(self, _input, _type, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_argmax(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_argmax(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_argmin(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_argmin(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_max(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_max(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_mean(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_mean(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_min(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_min(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_prod(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_prod(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_sum(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_sum(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn relu(
                &mut self,
                _input: root::taso::TensorHandle,
                _inPlace: bool,
            ) -> root::taso::TensorHandle {
                Graph_relu(self, _input, _inPlace)
            }
            #[inline]
            pub unsafe fn reshape(
                &mut self,
                _input: root::taso::TensorHandle,
                _shape: *const [u64; 3usize],
            ) -> root::taso::TensorHandle {
                Graph_reshape(self, _input, _shape)
            }
            #[inline]
            pub unsafe fn resize(
                &mut self,
                _input: root::taso::TensorHandle,
                _shape: *const [u64; 3usize],
            ) -> root::taso::TensorHandle {
                Graph_resize(self, _input, _shape)
            }
            #[inline]
            pub unsafe fn round(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_round(self, _input)
            }
            #[inline]
            pub unsafe fn shape(
                &mut self,
                _input: root::taso::TensorHandle,
                _type: root::taso::OpType,
            ) -> root::taso::TensorHandle {
                Graph_shape(self, _input, _type)
            }
            #[inline]
            pub unsafe fn slice(
                &mut self,
                _input: root::taso::TensorHandle,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            ) -> root::taso::TensorHandle {
                Graph_slice(self, _input, _start, _end, _axes, _steps)
            }
            #[inline]
            pub unsafe fn sigmoid(
                &mut self,
                _input: root::taso::TensorHandle,
                _inPlace: bool,
            ) -> root::taso::TensorHandle {
                Graph_sigmoid(self, _input, _inPlace)
            }
            #[inline]
            pub unsafe fn split(
                &mut self,
                _input: root::taso::TensorHandle,
                _axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
                _outputs: *mut root::taso::TensorHandle,
            ) {
                Graph_split(self, _input, _axis, _sizes, _outputs)
            }
            #[inline]
            pub unsafe fn split_equal(
                &mut self,
                _input: root::taso::TensorHandle,
                _axis: ::std::os::raw::c_int,
                _num: ::std::os::raw::c_int,
                _outputs: *mut root::taso::TensorHandle,
            ) {
                Graph_split_equal(self, _input, _axis, _num, _outputs)
            }
            #[inline]
            pub unsafe fn sqrt(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_sqrt(self, _input)
            }
            #[inline]
            pub unsafe fn squeeze(
                &mut self,
                input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
            ) -> root::taso::TensorHandle {
                Graph_squeeze(self, input, axes)
            }
            #[inline]
            pub unsafe fn transpose(
                &mut self,
                _input: root::taso::TensorHandle,
                _perm: *const [u64; 3usize],
                _shuffle: bool,
            ) -> root::taso::TensorHandle {
                Graph_transpose(self, _input, _perm, _shuffle)
            }
            #[inline]
            pub unsafe fn tanh(
                &mut self,
                _input: root::taso::TensorHandle,
                _inPlace: bool,
            ) -> root::taso::TensorHandle {
                Graph_tanh(self, _input, _inPlace)
            }
            #[inline]
            pub unsafe fn topk(
                &mut self,
                _input: root::taso::TensorHandle,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
                outputs: *mut root::taso::Tensor,
            ) {
                Graph_topk(self, _input, _axis, _numk, _largest, _sorted, outputs)
            }
            #[inline]
            pub unsafe fn unsqueeze(
                &mut self,
                input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
            ) -> root::taso::TensorHandle {
                Graph_unsqueeze(self, input, axes)
            }
            #[inline]
            pub unsafe fn where_(
                &mut self,
                _cond: root::taso::TensorHandle,
                _x: root::taso::TensorHandle,
                _y: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_where(self, _cond, _x, _y)
            }
            #[inline]
            pub unsafe fn find_op_or_fail(&mut self, guid: root::size_t) -> root::taso::Op {
                Graph_find_op_or_fail(self, guid)
            }
            #[inline]
            pub unsafe fn optimize(
                &mut self,
                alpha: f32,
                budget: ::std::os::raw::c_int,
                print_subst: bool,
            ) -> *mut root::taso::Graph {
                Graph_optimize(self, alpha, budget, print_subst)
            }
            #[inline]
            pub unsafe fn preprocess_weights(&mut self) -> *mut root::taso::Graph {
                Graph_preprocess_weights(self)
            }
            #[inline]
            pub unsafe fn get_operator_list(
                &mut self,
                opList: *mut root::taso::Op,
                maxNumOps: root::size_t,
            ) -> ::std::os::raw::c_int {
                Graph_get_operator_list(self, opList, maxNumOps)
            }
            #[inline]
            pub unsafe fn get_input_edges(
                &mut self,
                opList: *mut root::taso::Edge,
                guid: root::size_t,
            ) -> ::std::os::raw::c_int {
                Graph_get_input_edges(self, opList, guid)
            }
            #[inline]
            pub unsafe fn get_operator_type(&mut self, guid: root::size_t) -> root::taso::OpType {
                Graph_get_operator_type(self, guid)
            }
            #[inline]
            pub unsafe fn get_operator_int_attr(
                &mut self,
                guid: root::size_t,
                attr: root::taso::PMParameter,
            ) -> ::std::os::raw::c_int {
                Graph_get_operator_int_attr(self, guid, attr)
            }
            #[inline]
            pub unsafe fn get_num_outputs(&mut self, guid: root::size_t) -> ::std::os::raw::c_int {
                Graph_get_num_outputs(self, guid)
            }
            #[inline]
            pub unsafe fn get_input_dims(
                &mut self,
                guid: root::size_t,
                dims: *mut ::std::os::raw::c_int,
                idx: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int {
                Graph_get_input_dims(self, guid, dims, idx)
            }
            #[inline]
            pub unsafe fn get_weight_value(
                &mut self,
                guid: root::size_t,
                value: *mut root::taso::DATATYPE,
            ) {
                Graph_get_weight_value(self, guid, value)
            }
            #[inline]
            pub unsafe fn get_output_dims(
                &mut self,
                guid: root::size_t,
                dims: *mut ::std::os::raw::c_int,
                idx: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int {
                Graph_get_output_dims(self, guid, dims, idx)
            }
            #[inline]
            pub unsafe fn get_split_lens(
                &mut self,
                guid: root::size_t,
                lens: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int {
                Graph_get_split_lens(self, guid, lens)
            }
            #[inline]
            pub unsafe fn num_in_edges(&mut self, op: root::taso::Op) -> root::size_t {
                Graph_num_in_edges(self, op)
            }
            #[inline]
            pub unsafe fn num_out_edges(&mut self, op: root::taso::Op) -> root::size_t {
                Graph_num_out_edges(self, op)
            }
            #[inline]
            pub unsafe fn hash(&mut self) -> root::size_t {
                Graph_hash(self)
            }
            #[inline]
            pub unsafe fn print(&mut self) {
                Graph_print(self)
            }
            #[inline]
            pub unsafe fn check_correctness(&mut self) -> bool {
                Graph_check_correctness(self)
            }
            #[inline]
            pub unsafe fn has_loop(&mut self) -> bool {
                Graph_has_loop(self)
            }
            #[inline]
            pub unsafe fn total_cost(&mut self) -> f32 {
                Graph_total_cost(self)
            }
            #[inline]
            pub unsafe fn run(&mut self) -> f32 {
                Graph_run(self)
            }
            #[inline]
            pub unsafe fn print_costs(&mut self) {
                Graph_print_costs(self)
            }
            #[inline]
            pub unsafe fn print_measurements(&mut self) {
                Graph_print_measurements(self)
            }
            #[inline]
            pub unsafe fn export_op(
                &mut self,
                file_stream: *mut root::std::ofstream,
                op: *mut root::taso::Op,
            ) {
                Graph_export_op(self, file_stream, op)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Graph_Graph(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Constant {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Constant() {
            assert_eq!(
                ::std::mem::size_of::<Constant>(),
                13856usize,
                concat!("Size of: ", stringify!(Constant))
            );
            assert_eq!(
                ::std::mem::align_of::<Constant>(),
                8usize,
                concat!("Alignment of ", stringify!(Constant))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8ConstantC1EPNS_5ModelEiPiNS_6OpTypeE"]
            pub fn Constant_Constant(
                this: *mut root::taso::Constant,
                _model: *mut root::taso::Model,
                ndim: ::std::os::raw::c_int,
                dims: *mut ::std::os::raw::c_int,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8ConstantD1Ev"]
            pub fn Constant_Constant_destructor(this: *mut root::taso::Constant);
        }
        impl Constant {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                ndim: ::std::os::raw::c_int,
                dims: *mut ::std::os::raw::c_int,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Constant_Constant(__bindgen_tmp.as_mut_ptr(), _model, ndim, dims, _type);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Constant_Constant_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8Constant7forwardEb"]
            pub fn Constant_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8Constant3mapEv"]
            pub fn Constant_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8Constant5unmapEv"]
            pub fn Constant_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8Constant17get_int_parameterENS_11PMParameterEPi"]
            pub fn Constant_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8Constant13collect_costsERfS1_S1_Ri"]
            pub fn Constant_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Conv2D {
            pub _base: root::taso::OpBase,
            pub strideH: ::std::os::raw::c_int,
            pub strideW: ::std::os::raw::c_int,
            pub padding: root::taso::PaddingMode,
            pub activation: root::taso::ActiMode,
            pub biasPtr: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_Conv2D() {
            assert_eq!(
                ::std::mem::size_of::<Conv2D>(),
                13880usize,
                concat!("Size of: ", stringify!(Conv2D))
            );
            assert_eq!(
                ::std::mem::align_of::<Conv2D>(),
                8usize,
                concat!("Alignment of ", stringify!(Conv2D))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Conv2D>())).strideH as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Conv2D),
                    "::",
                    stringify!(strideH)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Conv2D>())).strideW as *const _ as usize },
                13860usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Conv2D),
                    "::",
                    stringify!(strideW)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Conv2D>())).padding as *const _ as usize },
                13864usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Conv2D),
                    "::",
                    stringify!(padding)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Conv2D>())).activation as *const _ as usize },
                13868usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Conv2D),
                    "::",
                    stringify!(activation)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Conv2D>())).biasPtr as *const _ as usize },
                13872usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Conv2D),
                    "::",
                    stringify!(biasPtr)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2D11get_paddingEPiS1_"]
            pub fn Conv2D_get_padding(
                this: *mut root::taso::Conv2D,
                padH: *mut ::std::os::raw::c_int,
                padW: *mut ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2DC1EPNS_5ModelENS_6TensorES3_iiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Conv2D_Conv2D(
                this: *mut root::taso::Conv2D,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2DD1Ev"]
            pub fn Conv2D_Conv2D_destructor(this: *mut root::taso::Conv2D);
        }
        impl Conv2D {
            #[inline]
            pub unsafe fn get_padding(
                &mut self,
                padH: *mut ::std::os::raw::c_int,
                padW: *mut ::std::os::raw::c_int,
            ) {
                Conv2D_get_padding(self, padH, padW)
            }
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Conv2D_Conv2D(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _weight,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Conv2D_Conv2D_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2D7forwardEb"]
            pub fn Conv2D_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2D3mapEv"]
            pub fn Conv2D_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2D5unmapEv"]
            pub fn Conv2D_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2D17get_int_parameterENS_11PMParameterEPi"]
            pub fn Conv2D_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2D13collect_costsERfS1_S1_Ri"]
            pub fn Conv2D_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Matmul {
            pub _base: root::taso::OpBase,
            pub outputC: ::std::os::raw::c_int,
            pub activation: root::taso::ActiMode,
        }
        #[test]
        fn bindgen_test_layout_Matmul() {
            assert_eq!(
                ::std::mem::size_of::<Matmul>(),
                13864usize,
                concat!("Size of: ", stringify!(Matmul))
            );
            assert_eq!(
                ::std::mem::align_of::<Matmul>(),
                8usize,
                concat!("Alignment of ", stringify!(Matmul))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Matmul>())).outputC as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Matmul),
                    "::",
                    stringify!(outputC)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Matmul>())).activation as *const _ as usize },
                13860usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Matmul),
                    "::",
                    stringify!(activation)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6MatmulC1EPNS_5ModelENS_6TensorES3_NS_8ActiModeE"]
            pub fn Matmul_Matmul(
                this: *mut root::taso::Matmul,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _actiMode: root::taso::ActiMode,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6MatmulD1Ev"]
            pub fn Matmul_Matmul_destructor(this: *mut root::taso::Matmul);
        }
        impl Matmul {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _actiMode: root::taso::ActiMode,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Matmul_Matmul(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _weight,
                    _actiMode,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Matmul_Matmul_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Matmul7forwardEb"]
            pub fn Matmul_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Matmul3mapEv"]
            pub fn Matmul_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Matmul5unmapEv"]
            pub fn Matmul_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Matmul17get_int_parameterENS_11PMParameterEPi"]
            pub fn Matmul_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Matmul13collect_costsERfS1_S1_Ri"]
            pub fn Matmul_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Mul {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Mul() {
            assert_eq!(
                ::std::mem::size_of::<Mul>(),
                13856usize,
                concat!("Size of: ", stringify!(Mul))
            );
            assert_eq!(
                ::std::mem::align_of::<Mul>(),
                8usize,
                concat!("Alignment of ", stringify!(Mul))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3MulC1EPNS_5ModelERKNS_6TensorES5_"]
            pub fn Mul_Mul(
                this: *mut root::taso::Mul,
                _model: *mut root::taso::Model,
                x: *const root::taso::Tensor,
                y: *const root::taso::Tensor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3MulD1Ev"]
            pub fn Mul_Mul_destructor(this: *mut root::taso::Mul);
        }
        impl Mul {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                x: *const root::taso::Tensor,
                y: *const root::taso::Tensor,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Mul_Mul(__bindgen_tmp.as_mut_ptr(), _model, x, y);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Mul_Mul_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Mul7forwardEb"]
            pub fn Mul_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Mul3mapEv"]
            pub fn Mul_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Mul5unmapEv"]
            pub fn Mul_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Mul17get_int_parameterENS_11PMParameterEPi"]
            pub fn Mul_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Mul13collect_costsERfS1_S1_Ri"]
            pub fn Mul_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Pool2D {
            pub _base: root::taso::OpBase,
            pub kernelH: ::std::os::raw::c_int,
            pub kernelW: ::std::os::raw::c_int,
            pub strideH: ::std::os::raw::c_int,
            pub strideW: ::std::os::raw::c_int,
            pub padding: root::taso::PaddingMode,
            pub activation: root::taso::ActiMode,
        }
        #[test]
        fn bindgen_test_layout_Pool2D() {
            assert_eq!(
                ::std::mem::size_of::<Pool2D>(),
                13880usize,
                concat!("Size of: ", stringify!(Pool2D))
            );
            assert_eq!(
                ::std::mem::align_of::<Pool2D>(),
                8usize,
                concat!("Alignment of ", stringify!(Pool2D))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2D>())).kernelH as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2D),
                    "::",
                    stringify!(kernelH)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2D>())).kernelW as *const _ as usize },
                13860usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2D),
                    "::",
                    stringify!(kernelW)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2D>())).strideH as *const _ as usize },
                13864usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2D),
                    "::",
                    stringify!(strideH)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2D>())).strideW as *const _ as usize },
                13868usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2D),
                    "::",
                    stringify!(strideW)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2D>())).padding as *const _ as usize },
                13872usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2D),
                    "::",
                    stringify!(padding)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2D>())).activation as *const _ as usize },
                13876usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2D),
                    "::",
                    stringify!(activation)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2D11get_paddingEPiS1_"]
            pub fn Pool2D_get_padding(
                this: *mut root::taso::Pool2D,
                padH: *mut ::std::os::raw::c_int,
                padW: *mut ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2DC1EPNS_5ModelENS_6TensorES3_NS_6OpTypeEiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Pool2D_Pool2D(
                this: *mut root::taso::Pool2D,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _type: root::taso::OpType,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2DD1Ev"]
            pub fn Pool2D_Pool2D_destructor(this: *mut root::taso::Pool2D);
        }
        impl Pool2D {
            #[inline]
            pub unsafe fn get_padding(
                &mut self,
                padH: *mut ::std::os::raw::c_int,
                padW: *mut ::std::os::raw::c_int,
            ) {
                Pool2D_get_padding(self, padH, padW)
            }
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _type: root::taso::OpType,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Pool2D_Pool2D(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _weight,
                    _type,
                    _kernelH,
                    _kernelW,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Pool2D_Pool2D_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2D17get_int_parameterENS_11PMParameterEPi"]
            pub fn Pool2D_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2D7forwardEb"]
            pub fn Pool2D_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2D3mapEv"]
            pub fn Pool2D_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2D5unmapEv"]
            pub fn Pool2D_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2D13collect_costsERfS1_S1_Ri"]
            pub fn Pool2D_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Activation {
            pub _base: root::taso::OpBase,
            pub inPlace: bool,
        }
        #[test]
        fn bindgen_test_layout_Activation() {
            assert_eq!(
                ::std::mem::size_of::<Activation>(),
                13864usize,
                concat!("Size of: ", stringify!(Activation))
            );
            assert_eq!(
                ::std::mem::align_of::<Activation>(),
                8usize,
                concat!("Alignment of ", stringify!(Activation))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Activation>())).inPlace as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Activation),
                    "::",
                    stringify!(inPlace)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10ActivationC1EPNS_5ModelENS_6TensorENS_6OpTypeEb"]
            pub fn Activation_Activation(
                this: *mut root::taso::Activation,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
                _inPlace: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10ActivationD1Ev"]
            pub fn Activation_Activation_destructor(this: *mut root::taso::Activation);
        }
        impl Activation {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
                _inPlace: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Activation_Activation(__bindgen_tmp.as_mut_ptr(), _model, _input, _type, _inPlace);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Activation_Activation_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10Activation17get_int_parameterENS_11PMParameterEPi"]
            pub fn Activation_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10Activation7forwardEb"]
            pub fn Activation_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10Activation3mapEv"]
            pub fn Activation_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10Activation5unmapEv"]
            pub fn Activation_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10Activation13collect_costsERfS1_S1_Ri"]
            pub fn Activation_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct BatchNorm {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_BatchNorm() {
            assert_eq!(
                ::std::mem::size_of::<BatchNorm>(),
                13856usize,
                concat!("Size of: ", stringify!(BatchNorm))
            );
            assert_eq!(
                ::std::mem::align_of::<BatchNorm>(),
                8usize,
                concat!("Alignment of ", stringify!(BatchNorm))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNormC1EPNS_5ModelERKNS_6TensorES5_S5_S5_S5_"]
            pub fn BatchNorm_BatchNorm(
                this: *mut root::taso::BatchNorm,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _scale: *const root::taso::Tensor,
                _bias: *const root::taso::Tensor,
                _mean: *const root::taso::Tensor,
                _var: *const root::taso::Tensor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNormD1Ev"]
            pub fn BatchNorm_BatchNorm_destructor(this: *mut root::taso::BatchNorm);
        }
        impl BatchNorm {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _scale: *const root::taso::Tensor,
                _bias: *const root::taso::Tensor,
                _mean: *const root::taso::Tensor,
                _var: *const root::taso::Tensor,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                BatchNorm_BatchNorm(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _scale,
                    _bias,
                    _mean,
                    _var,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                BatchNorm_BatchNorm_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNorm17get_int_parameterENS_11PMParameterEPi"]
            pub fn BatchNorm_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNorm7forwardEb"]
            pub fn BatchNorm_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNorm3mapEv"]
            pub fn BatchNorm_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNorm5unmapEv"]
            pub fn BatchNorm_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNorm13collect_costsERfS1_S1_Ri"]
            pub fn BatchNorm_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Cast {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Cast() {
            assert_eq!(
                ::std::mem::size_of::<Cast>(),
                13856usize,
                concat!("Size of: ", stringify!(Cast))
            );
            assert_eq!(
                ::std::mem::align_of::<Cast>(),
                8usize,
                concat!("Alignment of ", stringify!(Cast))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4CastC1EPNS_5ModelERKNS_6TensorENS_8DataTypeE"]
            pub fn Cast_Cast(
                this: *mut root::taso::Cast,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _datatype: root::taso::DataType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4CastD1Ev"]
            pub fn Cast_Cast_destructor(this: *mut root::taso::Cast);
        }
        impl Cast {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _datatype: root::taso::DataType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Cast_Cast(__bindgen_tmp.as_mut_ptr(), _model, _input, _datatype);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Cast_Cast_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4Cast17get_int_parameterENS_11PMParameterEPi"]
            pub fn Cast_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4Cast7forwardEb"]
            pub fn Cast_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4Cast3mapEv"]
            pub fn Cast_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4Cast5unmapEv"]
            pub fn Cast_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4Cast13collect_costsERfS1_S1_Ri"]
            pub fn Cast_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Concat {
            pub _base: root::taso::OpBase,
            pub axis: ::std::os::raw::c_int,
            pub needCopy: [bool; 6usize],
        }
        #[test]
        fn bindgen_test_layout_Concat() {
            assert_eq!(
                ::std::mem::size_of::<Concat>(),
                13872usize,
                concat!("Size of: ", stringify!(Concat))
            );
            assert_eq!(
                ::std::mem::align_of::<Concat>(),
                8usize,
                concat!("Alignment of ", stringify!(Concat))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Concat>())).axis as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Concat),
                    "::",
                    stringify!(axis)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Concat>())).needCopy as *const _ as usize },
                13860usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Concat),
                    "::",
                    stringify!(needCopy)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6ConcatC1EPNS_5ModelEiiPNS_6TensorEPb"]
            pub fn Concat_Concat(
                this: *mut root::taso::Concat,
                _model: *mut root::taso::Model,
                _axis: ::std::os::raw::c_int,
                _n: ::std::os::raw::c_int,
                _inputs: *mut root::taso::Tensor,
                _needCopy: *mut bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6ConcatD1Ev"]
            pub fn Concat_Concat_destructor(this: *mut root::taso::Concat);
        }
        impl Concat {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _axis: ::std::os::raw::c_int,
                _n: ::std::os::raw::c_int,
                _inputs: *mut root::taso::Tensor,
                _needCopy: *mut bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Concat_Concat(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _axis,
                    _n,
                    _inputs,
                    _needCopy,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Concat_Concat_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Concat17get_int_parameterENS_11PMParameterEPi"]
            pub fn Concat_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Concat7forwardEb"]
            pub fn Concat_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Concat3mapEv"]
            pub fn Concat_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Concat5unmapEv"]
            pub fn Concat_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Concat13collect_costsERfS1_S1_Ri"]
            pub fn Concat_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Element {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Element() {
            assert_eq!(
                ::std::mem::size_of::<Element>(),
                13856usize,
                concat!("Size of: ", stringify!(Element))
            );
            assert_eq!(
                ::std::mem::align_of::<Element>(),
                8usize,
                concat!("Alignment of ", stringify!(Element))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK4taso7Element16has_cudnn_kernelEv"]
            pub fn Element_has_cudnn_kernel(this: *const root::taso::Element) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7ElementC1EPNS_5ModelENS_6OpTypeERKNS_6TensorES6_"]
            pub fn Element_Element(
                this: *mut root::taso::Element,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
                _t1: *const root::taso::Tensor,
                _t2: *const root::taso::Tensor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7ElementD1Ev"]
            pub fn Element_Element_destructor(this: *mut root::taso::Element);
        }
        impl Element {
            #[inline]
            pub unsafe fn has_cudnn_kernel(&self) -> bool {
                Element_has_cudnn_kernel(self)
            }
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
                _t1: *const root::taso::Tensor,
                _t2: *const root::taso::Tensor,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Element_Element(__bindgen_tmp.as_mut_ptr(), _model, _type, _t1, _t2);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Element_Element_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Element17get_int_parameterENS_11PMParameterEPi"]
            pub fn Element_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Element7forwardEb"]
            pub fn Element_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Element3mapEv"]
            pub fn Element_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Element5unmapEv"]
            pub fn Element_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Element13collect_costsERfS1_S1_Ri"]
            pub fn Element_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ElementWiseUnary {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_ElementWiseUnary() {
            assert_eq!(
                ::std::mem::size_of::<ElementWiseUnary>(),
                13856usize,
                concat!("Size of: ", stringify!(ElementWiseUnary))
            );
            assert_eq!(
                ::std::mem::align_of::<ElementWiseUnary>(),
                8usize,
                concat!("Alignment of ", stringify!(ElementWiseUnary))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnaryC1EPNS_5ModelERKNS_6TensorENS_6OpTypeE"]
            pub fn ElementWiseUnary_ElementWiseUnary(
                this: *mut root::taso::ElementWiseUnary,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnaryD1Ev"]
            pub fn ElementWiseUnary_ElementWiseUnary_destructor(
                this: *mut root::taso::ElementWiseUnary,
            );
        }
        impl ElementWiseUnary {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ElementWiseUnary_ElementWiseUnary(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _type,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ElementWiseUnary_ElementWiseUnary_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnary17get_int_parameterENS_11PMParameterEPi"]
            pub fn ElementWiseUnary_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnary7forwardEb"]
            pub fn ElementWiseUnary_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnary3mapEv"]
            pub fn ElementWiseUnary_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnary5unmapEv"]
            pub fn ElementWiseUnary_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnary13collect_costsERfS1_S1_Ri"]
            pub fn ElementWiseUnary_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Enlarge {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Enlarge() {
            assert_eq!(
                ::std::mem::size_of::<Enlarge>(),
                13856usize,
                concat!("Size of: ", stringify!(Enlarge))
            );
            assert_eq!(
                ::std::mem::align_of::<Enlarge>(),
                8usize,
                concat!("Alignment of ", stringify!(Enlarge))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7EnlargeC1EPNS_5ModelENS_6TensorES3_"]
            pub fn Enlarge_Enlarge(
                this: *mut root::taso::Enlarge,
                _model: *mut root::taso::Model,
                _w1: root::taso::Tensor,
                _w2: root::taso::Tensor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7EnlargeD1Ev"]
            pub fn Enlarge_Enlarge_destructor(this: *mut root::taso::Enlarge);
        }
        impl Enlarge {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _w1: root::taso::Tensor,
                _w2: root::taso::Tensor,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Enlarge_Enlarge(__bindgen_tmp.as_mut_ptr(), _model, _w1, _w2);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Enlarge_Enlarge_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Enlarge17get_int_parameterENS_11PMParameterEPi"]
            pub fn Enlarge_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Enlarge7forwardEb"]
            pub fn Enlarge_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Enlarge3mapEv"]
            pub fn Enlarge_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Enlarge5unmapEv"]
            pub fn Enlarge_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Enlarge13collect_costsERfS1_S1_Ri"]
            pub fn Enlarge_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct TopK {
            pub _base: root::taso::OpBase,
            pub axis: ::std::os::raw::c_int,
            pub largest: bool,
            pub sorted: bool,
        }
        #[test]
        fn bindgen_test_layout_TopK() {
            assert_eq!(
                ::std::mem::size_of::<TopK>(),
                13864usize,
                concat!("Size of: ", stringify!(TopK))
            );
            assert_eq!(
                ::std::mem::align_of::<TopK>(),
                8usize,
                concat!("Alignment of ", stringify!(TopK))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TopK>())).axis as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TopK),
                    "::",
                    stringify!(axis)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TopK>())).largest as *const _ as usize },
                13860usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TopK),
                    "::",
                    stringify!(largest)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TopK>())).sorted as *const _ as usize },
                13861usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TopK),
                    "::",
                    stringify!(sorted)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopKC1EPNS_5ModelERKNS_6TensorEiibb"]
            pub fn TopK_TopK(
                this: *mut root::taso::TopK,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopKD1Ev"]
            pub fn TopK_TopK_destructor(this: *mut root::taso::TopK);
        }
        impl TopK {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                TopK_TopK(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _axis,
                    _numk,
                    _largest,
                    _sorted,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                TopK_TopK_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopK17get_int_parameterENS_11PMParameterEPi"]
            pub fn TopK_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopK7forwardEb"]
            pub fn TopK_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopK3mapEv"]
            pub fn TopK_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopK5unmapEv"]
            pub fn TopK_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopK13collect_costsERfS1_S1_Ri"]
            pub fn TopK_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct MergeGConv {
            pub _base: root::taso::OpBase,
            pub count: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_MergeGConv() {
            assert_eq!(
                ::std::mem::size_of::<MergeGConv>(),
                13864usize,
                concat!("Size of: ", stringify!(MergeGConv))
            );
            assert_eq!(
                ::std::mem::align_of::<MergeGConv>(),
                8usize,
                concat!("Alignment of ", stringify!(MergeGConv))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<MergeGConv>())).count as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MergeGConv),
                    "::",
                    stringify!(count)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10MergeGConvC1EPNS_5ModelERKNS_6TensorEi"]
            pub fn MergeGConv_MergeGConv(
                this: *mut root::taso::MergeGConv,
                _model: *mut root::taso::Model,
                _weight: *const root::taso::Tensor,
                count: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10MergeGConvD1Ev"]
            pub fn MergeGConv_MergeGConv_destructor(this: *mut root::taso::MergeGConv);
        }
        impl MergeGConv {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _weight: *const root::taso::Tensor,
                count: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                MergeGConv_MergeGConv(__bindgen_tmp.as_mut_ptr(), _model, _weight, count);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                MergeGConv_MergeGConv_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10MergeGConv17get_int_parameterENS_11PMParameterEPi"]
            pub fn MergeGConv_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10MergeGConv7forwardEb"]
            pub fn MergeGConv_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10MergeGConv3mapEv"]
            pub fn MergeGConv_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10MergeGConv5unmapEv"]
            pub fn MergeGConv_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10MergeGConv13collect_costsERfS1_S1_Ri"]
            pub fn MergeGConv_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct NoOp {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_NoOp() {
            assert_eq!(
                ::std::mem::size_of::<NoOp>(),
                13856usize,
                concat!("Size of: ", stringify!(NoOp))
            );
            assert_eq!(
                ::std::mem::align_of::<NoOp>(),
                8usize,
                concat!("Alignment of ", stringify!(NoOp))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4NoOpC1EPNS_5ModelENS_6TensorENS_6OpTypeE"]
            pub fn NoOp_NoOp(
                this: *mut root::taso::NoOp,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4NoOpD1Ev"]
            pub fn NoOp_NoOp_destructor(this: *mut root::taso::NoOp);
        }
        impl NoOp {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                NoOp_NoOp(__bindgen_tmp.as_mut_ptr(), _model, _input, _type);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                NoOp_NoOp_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4NoOp17get_int_parameterENS_11PMParameterEPi"]
            pub fn NoOp_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4NoOp7forwardEb"]
            pub fn NoOp_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4NoOp3mapEv"]
            pub fn NoOp_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4NoOp5unmapEv"]
            pub fn NoOp_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4NoOp13collect_costsERfS1_S1_Ri"]
            pub fn NoOp_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Pad {
            pub _base: root::taso::OpBase,
            pub pad_before: [u64; 3usize],
            pub pad_after: [u64; 3usize],
            pub pad_value: f32,
        }
        #[test]
        fn bindgen_test_layout_Pad() {
            assert_eq!(
                ::std::mem::size_of::<Pad>(),
                13912usize,
                concat!("Size of: ", stringify!(Pad))
            );
            assert_eq!(
                ::std::mem::align_of::<Pad>(),
                8usize,
                concat!("Alignment of ", stringify!(Pad))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pad>())).pad_before as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pad),
                    "::",
                    stringify!(pad_before)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pad>())).pad_after as *const _ as usize },
                13880usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pad),
                    "::",
                    stringify!(pad_after)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pad>())).pad_value as *const _ as usize },
                13904usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pad),
                    "::",
                    stringify!(pad_value)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3PadC1EPNS_5ModelERKNS_6TensorERKSt6vectorIiSaIiEESA_f"]
            pub fn Pad_Pad(
                this: *mut root::taso::Pad,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3PadD1Ev"]
            pub fn Pad_Pad_destructor(this: *mut root::taso::Pad);
        }
        impl Pad {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Pad_Pad(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _pad_before,
                    _pad_after,
                    _pad_value,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Pad_Pad_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Pad17get_int_parameterENS_11PMParameterEPi"]
            pub fn Pad_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Pad7forwardEb"]
            pub fn Pad_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Pad3mapEv"]
            pub fn Pad_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Pad5unmapEv"]
            pub fn Pad_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Pad13collect_costsERfS1_S1_Ri"]
            pub fn Pad_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Reduce {
            pub _base: root::taso::OpBase,
            pub keepdims: bool,
            pub axes: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Reduce() {
            assert_eq!(
                ::std::mem::size_of::<Reduce>(),
                13888usize,
                concat!("Size of: ", stringify!(Reduce))
            );
            assert_eq!(
                ::std::mem::align_of::<Reduce>(),
                8usize,
                concat!("Alignment of ", stringify!(Reduce))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Reduce>())).keepdims as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Reduce),
                    "::",
                    stringify!(keepdims)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Reduce>())).axes as *const _ as usize },
                13864usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Reduce),
                    "::",
                    stringify!(axes)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6ReduceC1EPNS_5ModelERKNS_6TensorENS_6OpTypeERKSt6vectorIiSaIiEEb"]
            pub fn Reduce_Reduce(
                this: *mut root::taso::Reduce,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
                _axes: *const [u64; 3usize],
                _keepdims: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6ReduceD1Ev"]
            pub fn Reduce_Reduce_destructor(this: *mut root::taso::Reduce);
        }
        impl Reduce {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
                _axes: *const [u64; 3usize],
                _keepdims: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Reduce_Reduce(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _type,
                    _axes,
                    _keepdims,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Reduce_Reduce_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Reduce17get_int_parameterENS_11PMParameterEPi"]
            pub fn Reduce_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Reduce7forwardEb"]
            pub fn Reduce_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Reduce3mapEv"]
            pub fn Reduce_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Reduce5unmapEv"]
            pub fn Reduce_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Reduce13collect_costsERfS1_S1_Ri"]
            pub fn Reduce_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Reshape {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Reshape() {
            assert_eq!(
                ::std::mem::size_of::<Reshape>(),
                13856usize,
                concat!("Size of: ", stringify!(Reshape))
            );
            assert_eq!(
                ::std::mem::align_of::<Reshape>(),
                8usize,
                concat!("Alignment of ", stringify!(Reshape))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7ReshapeC1EPNS_5ModelENS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Reshape_Reshape(
                this: *mut root::taso::Reshape,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                shape: *const [u64; 3usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7ReshapeD1Ev"]
            pub fn Reshape_Reshape_destructor(this: *mut root::taso::Reshape);
        }
        impl Reshape {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                shape: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Reshape_Reshape(__bindgen_tmp.as_mut_ptr(), _model, _input, shape);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Reshape_Reshape_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Reshape17get_int_parameterENS_11PMParameterEPi"]
            pub fn Reshape_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Reshape7forwardEb"]
            pub fn Reshape_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Reshape3mapEv"]
            pub fn Reshape_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Reshape5unmapEv"]
            pub fn Reshape_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Reshape13collect_costsERfS1_S1_Ri"]
            pub fn Reshape_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Resize {
            pub _base: root::taso::OpBase,
            pub shape: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Resize() {
            assert_eq!(
                ::std::mem::size_of::<Resize>(),
                13880usize,
                concat!("Size of: ", stringify!(Resize))
            );
            assert_eq!(
                ::std::mem::align_of::<Resize>(),
                8usize,
                concat!("Alignment of ", stringify!(Resize))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Resize>())).shape as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Resize),
                    "::",
                    stringify!(shape)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6ResizeC1EPNS_5ModelERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Resize_Resize(
                this: *mut root::taso::Resize,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _shape: *const [u64; 3usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6ResizeD1Ev"]
            pub fn Resize_Resize_destructor(this: *mut root::taso::Resize);
        }
        impl Resize {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _shape: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Resize_Resize(__bindgen_tmp.as_mut_ptr(), _model, _input, _shape);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Resize_Resize_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Resize17get_int_parameterENS_11PMParameterEPi"]
            pub fn Resize_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Resize7forwardEb"]
            pub fn Resize_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Resize3mapEv"]
            pub fn Resize_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Resize5unmapEv"]
            pub fn Resize_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Resize13collect_costsERfS1_S1_Ri"]
            pub fn Resize_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Shape {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Shape() {
            assert_eq!(
                ::std::mem::size_of::<Shape>(),
                13856usize,
                concat!("Size of: ", stringify!(Shape))
            );
            assert_eq!(
                ::std::mem::align_of::<Shape>(),
                8usize,
                concat!("Alignment of ", stringify!(Shape))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5ShapeC1EPNS_5ModelERKNS_6TensorENS_6OpTypeE"]
            pub fn Shape_Shape(
                this: *mut root::taso::Shape,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5ShapeD1Ev"]
            pub fn Shape_Shape_destructor(this: *mut root::taso::Shape);
        }
        impl Shape {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Shape_Shape(__bindgen_tmp.as_mut_ptr(), _model, _input, _type);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Shape_Shape_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Shape17get_int_parameterENS_11PMParameterEPi"]
            pub fn Shape_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Shape7forwardEb"]
            pub fn Shape_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Shape3mapEv"]
            pub fn Shape_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Shape5unmapEv"]
            pub fn Shape_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Shape13collect_costsERfS1_S1_Ri"]
            pub fn Shape_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Slice {
            pub _base: root::taso::OpBase,
            pub start: [u64; 3usize],
            pub end: [u64; 3usize],
            pub axes: [u64; 3usize],
            pub steps: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Slice() {
            assert_eq!(
                ::std::mem::size_of::<Slice>(),
                13952usize,
                concat!("Size of: ", stringify!(Slice))
            );
            assert_eq!(
                ::std::mem::align_of::<Slice>(),
                8usize,
                concat!("Alignment of ", stringify!(Slice))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Slice>())).start as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Slice),
                    "::",
                    stringify!(start)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Slice>())).end as *const _ as usize },
                13880usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Slice),
                    "::",
                    stringify!(end)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Slice>())).axes as *const _ as usize },
                13904usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Slice),
                    "::",
                    stringify!(axes)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Slice>())).steps as *const _ as usize },
                13928usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Slice),
                    "::",
                    stringify!(steps)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5SliceC1EPNS_5ModelERKNS_6TensorERKSt6vectorIiSaIiEESA_SA_SA_"]
            pub fn Slice_Slice(
                this: *mut root::taso::Slice,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5SliceD1Ev"]
            pub fn Slice_Slice_destructor(this: *mut root::taso::Slice);
        }
        impl Slice {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Slice_Slice(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _start,
                    _end,
                    _axes,
                    _steps,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Slice_Slice_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Slice17get_int_parameterENS_11PMParameterEPi"]
            pub fn Slice_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Slice7forwardEb"]
            pub fn Slice_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Slice3mapEv"]
            pub fn Slice_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Slice5unmapEv"]
            pub fn Slice_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Slice13collect_costsERfS1_S1_Ri"]
            pub fn Slice_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Split {
            pub _base: root::taso::OpBase,
            pub axis: ::std::os::raw::c_int,
            pub sizes: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Split() {
            assert_eq!(
                ::std::mem::size_of::<Split>(),
                13888usize,
                concat!("Size of: ", stringify!(Split))
            );
            assert_eq!(
                ::std::mem::align_of::<Split>(),
                8usize,
                concat!("Alignment of ", stringify!(Split))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Split>())).axis as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Split),
                    "::",
                    stringify!(axis)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Split>())).sizes as *const _ as usize },
                13864usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Split),
                    "::",
                    stringify!(sizes)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5SplitC1EPNS_5ModelERKNS_6TensorEiRKSt6vectorIiSaIiEE"]
            pub fn Split_Split(
                this: *mut root::taso::Split,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5SplitD1Ev"]
            pub fn Split_Split_destructor(this: *mut root::taso::Split);
        }
        impl Split {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Split_Split(__bindgen_tmp.as_mut_ptr(), _model, _input, axis, _sizes);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Split_Split_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Split17get_int_parameterENS_11PMParameterEPi"]
            pub fn Split_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Split7forwardEb"]
            pub fn Split_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Split3mapEv"]
            pub fn Split_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Split5unmapEv"]
            pub fn Split_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Split13collect_costsERfS1_S1_Ri"]
            pub fn Split_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Squeeze {
            pub _base: root::taso::OpBase,
            pub axes: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Squeeze() {
            assert_eq!(
                ::std::mem::size_of::<Squeeze>(),
                13880usize,
                concat!("Size of: ", stringify!(Squeeze))
            );
            assert_eq!(
                ::std::mem::align_of::<Squeeze>(),
                8usize,
                concat!("Alignment of ", stringify!(Squeeze))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Squeeze>())).axes as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Squeeze),
                    "::",
                    stringify!(axes)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7SqueezeC1EPNS_5ModelERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Squeeze_Squeeze(
                this: *mut root::taso::Squeeze,
                _model: *mut root::taso::Model,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7SqueezeD1Ev"]
            pub fn Squeeze_Squeeze_destructor(this: *mut root::taso::Squeeze);
        }
        impl Squeeze {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Squeeze_Squeeze(__bindgen_tmp.as_mut_ptr(), _model, input, axes);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Squeeze_Squeeze_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Squeeze17get_int_parameterENS_11PMParameterEPi"]
            pub fn Squeeze_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Squeeze7forwardEb"]
            pub fn Squeeze_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Squeeze3mapEv"]
            pub fn Squeeze_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Squeeze5unmapEv"]
            pub fn Squeeze_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Squeeze13collect_costsERfS1_S1_Ri"]
            pub fn Squeeze_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Transpose {
            pub _base: root::taso::OpBase,
            pub permIdx: ::std::os::raw::c_int,
            pub shuffle: bool,
        }
        #[test]
        fn bindgen_test_layout_Transpose() {
            assert_eq!(
                ::std::mem::size_of::<Transpose>(),
                13864usize,
                concat!("Size of: ", stringify!(Transpose))
            );
            assert_eq!(
                ::std::mem::align_of::<Transpose>(),
                8usize,
                concat!("Alignment of ", stringify!(Transpose))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Transpose>())).permIdx as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Transpose),
                    "::",
                    stringify!(permIdx)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Transpose>())).shuffle as *const _ as usize },
                13860usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Transpose),
                    "::",
                    stringify!(shuffle)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9TransposeC1EPNS_5ModelENS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Transpose_Transpose(
                this: *mut root::taso::Transpose,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                perm: *const [u64; 3usize],
                _shuffle: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9TransposeD1Ev"]
            pub fn Transpose_Transpose_destructor(this: *mut root::taso::Transpose);
        }
        impl Transpose {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                perm: *const [u64; 3usize],
                _shuffle: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Transpose_Transpose(__bindgen_tmp.as_mut_ptr(), _model, _input, perm, _shuffle);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Transpose_Transpose_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Transpose17get_int_parameterENS_11PMParameterEPi"]
            pub fn Transpose_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Transpose7forwardEb"]
            pub fn Transpose_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Transpose3mapEv"]
            pub fn Transpose_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Transpose5unmapEv"]
            pub fn Transpose_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Transpose13collect_costsERfS1_S1_Ri"]
            pub fn Transpose_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Unsqueeze {
            pub _base: root::taso::OpBase,
            pub axes: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Unsqueeze() {
            assert_eq!(
                ::std::mem::size_of::<Unsqueeze>(),
                13880usize,
                concat!("Size of: ", stringify!(Unsqueeze))
            );
            assert_eq!(
                ::std::mem::align_of::<Unsqueeze>(),
                8usize,
                concat!("Alignment of ", stringify!(Unsqueeze))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Unsqueeze>())).axes as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Unsqueeze),
                    "::",
                    stringify!(axes)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9UnsqueezeC1EPNS_5ModelERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Unsqueeze_Unsqueeze(
                this: *mut root::taso::Unsqueeze,
                _model: *mut root::taso::Model,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9UnsqueezeD1Ev"]
            pub fn Unsqueeze_Unsqueeze_destructor(this: *mut root::taso::Unsqueeze);
        }
        impl Unsqueeze {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Unsqueeze_Unsqueeze(__bindgen_tmp.as_mut_ptr(), _model, input, axes);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Unsqueeze_Unsqueeze_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Unsqueeze17get_int_parameterENS_11PMParameterEPi"]
            pub fn Unsqueeze_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Unsqueeze7forwardEb"]
            pub fn Unsqueeze_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Unsqueeze3mapEv"]
            pub fn Unsqueeze_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Unsqueeze5unmapEv"]
            pub fn Unsqueeze_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Unsqueeze13collect_costsERfS1_S1_Ri"]
            pub fn Unsqueeze_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Where {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Where() {
            assert_eq!(
                ::std::mem::size_of::<Where>(),
                13856usize,
                concat!("Size of: ", stringify!(Where))
            );
            assert_eq!(
                ::std::mem::align_of::<Where>(),
                8usize,
                concat!("Alignment of ", stringify!(Where))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5WhereC1EPNS_5ModelERKNS_6TensorES5_S5_"]
            pub fn Where_Where(
                this: *mut root::taso::Where,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _x: *const root::taso::Tensor,
                _y: *const root::taso::Tensor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5WhereD1Ev"]
            pub fn Where_Where_destructor(this: *mut root::taso::Where);
        }
        impl Where {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _x: *const root::taso::Tensor,
                _y: *const root::taso::Tensor,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Where_Where(__bindgen_tmp.as_mut_ptr(), _model, _input, _x, _y);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Where_Where_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Where17get_int_parameterENS_11PMParameterEPi"]
            pub fn Where_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Where7forwardEb"]
            pub fn Where_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Where3mapEv"]
            pub fn Where_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Where5unmapEv"]
            pub fn Where_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Where13collect_costsERfS1_S1_Ri"]
            pub fn Where_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct KeyCompare {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ActivationKey {
            pub keys: [::std::os::raw::c_int; 276usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso13ActivationKey10KEY_LENGTHE"]
            pub static ActivationKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_ActivationKey() {
            assert_eq!(
                ::std::mem::size_of::<ActivationKey>(),
                1104usize,
                concat!("Size of: ", stringify!(ActivationKey))
            );
            assert_eq!(
                ::std::mem::align_of::<ActivationKey>(),
                4usize,
                concat!("Alignment of ", stringify!(ActivationKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ActivationKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ActivationKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso13ActivationKeyC1ENS_6TensorENS_6OpTypeEb"]
            pub fn ActivationKey_ActivationKey(
                this: *mut root::taso::ActivationKey,
                arg1: root::taso::Tensor,
                arg2: root::taso::OpType,
                arg3: bool,
            );
        }
        impl ActivationKey {
            #[inline]
            pub unsafe fn new(
                arg1: root::taso::Tensor,
                arg2: root::taso::OpType,
                arg3: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ActivationKey_ActivationKey(__bindgen_tmp.as_mut_ptr(), arg1, arg2, arg3);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct BatchNormKey {
            pub keys: [::std::os::raw::c_int; 274usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso12BatchNormKey10KEY_LENGTHE"]
            pub static BatchNormKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_BatchNormKey() {
            assert_eq!(
                ::std::mem::size_of::<BatchNormKey>(),
                1096usize,
                concat!("Size of: ", stringify!(BatchNormKey))
            );
            assert_eq!(
                ::std::mem::align_of::<BatchNormKey>(),
                4usize,
                concat!("Alignment of ", stringify!(BatchNormKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<BatchNormKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BatchNormKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso12BatchNormKeyC1ENS_6TensorE"]
            pub fn BatchNormKey_BatchNormKey(
                this: *mut root::taso::BatchNormKey,
                arg1: root::taso::Tensor,
            );
        }
        impl BatchNormKey {
            #[inline]
            pub unsafe fn new(arg1: root::taso::Tensor) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                BatchNormKey_BatchNormKey(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct CastKey {
            pub keys: [::std::os::raw::c_int; 275usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7CastKey10KEY_LENGTHE"]
            pub static CastKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_CastKey() {
            assert_eq!(
                ::std::mem::size_of::<CastKey>(),
                1100usize,
                concat!("Size of: ", stringify!(CastKey))
            );
            assert_eq!(
                ::std::mem::align_of::<CastKey>(),
                4usize,
                concat!("Alignment of ", stringify!(CastKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<CastKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CastKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7CastKeyC1ERKNS_6TensorENS_8DataTypeE"]
            pub fn CastKey_CastKey(
                this: *mut root::taso::CastKey,
                _input: *const root::taso::Tensor,
                _datatype: root::taso::DataType,
            );
        }
        impl CastKey {
            #[inline]
            pub unsafe fn new(
                _input: *const root::taso::Tensor,
                _datatype: root::taso::DataType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                CastKey_CastKey(__bindgen_tmp.as_mut_ptr(), _input, _datatype);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ConcatKey {
            pub keys: [::std::os::raw::c_int; 1647usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9ConcatKey10KEY_LENGTHE"]
            pub static ConcatKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_ConcatKey() {
            assert_eq!(
                ::std::mem::size_of::<ConcatKey>(),
                6588usize,
                concat!("Size of: ", stringify!(ConcatKey))
            );
            assert_eq!(
                ::std::mem::align_of::<ConcatKey>(),
                4usize,
                concat!("Alignment of ", stringify!(ConcatKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ConcatKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ConcatKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9ConcatKeyC1EiiPNS_6TensorEPb"]
            pub fn ConcatKey_ConcatKey(
                this: *mut root::taso::ConcatKey,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut root::taso::Tensor,
                arg4: *mut bool,
            );
        }
        impl ConcatKey {
            #[inline]
            pub unsafe fn new(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut root::taso::Tensor,
                arg4: *mut bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ConcatKey_ConcatKey(__bindgen_tmp.as_mut_ptr(), arg1, arg2, arg3, arg4);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ConstantKey {
            pub keys: [::std::os::raw::c_int; 10usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso11ConstantKey10KEY_LENGTHE"]
            pub static ConstantKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_ConstantKey() {
            assert_eq!(
                ::std::mem::size_of::<ConstantKey>(),
                40usize,
                concat!("Size of: ", stringify!(ConstantKey))
            );
            assert_eq!(
                ::std::mem::align_of::<ConstantKey>(),
                4usize,
                concat!("Alignment of ", stringify!(ConstantKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ConstantKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ConstantKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso11ConstantKeyC1EiPiNS_6OpTypeE"]
            pub fn ConstantKey_ConstantKey(
                this: *mut root::taso::ConstantKey,
                arg1: ::std::os::raw::c_int,
                arg2: *mut ::std::os::raw::c_int,
                arg3: root::taso::OpType,
            );
        }
        impl ConstantKey {
            #[inline]
            pub unsafe fn new(
                arg1: ::std::os::raw::c_int,
                arg2: *mut ::std::os::raw::c_int,
                arg3: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ConstantKey_ConstantKey(__bindgen_tmp.as_mut_ptr(), arg1, arg2, arg3);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Conv2DKey {
            pub keys: [::std::os::raw::c_int; 552usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Conv2DKey10KEY_LENGTHE"]
            pub static Conv2DKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_Conv2DKey() {
            assert_eq!(
                ::std::mem::size_of::<Conv2DKey>(),
                2208usize,
                concat!("Size of: ", stringify!(Conv2DKey))
            );
            assert_eq!(
                ::std::mem::align_of::<Conv2DKey>(),
                4usize,
                concat!("Alignment of ", stringify!(Conv2DKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Conv2DKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Conv2DKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Conv2DKeyC1ENS_6TensorES1_iiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Conv2DKey_Conv2DKey(
                this: *mut root::taso::Conv2DKey,
                arg1: root::taso::Tensor,
                arg2: root::taso::Tensor,
                arg3: ::std::os::raw::c_int,
                arg4: ::std::os::raw::c_int,
                arg5: root::taso::PaddingMode,
                arg6: root::taso::ActiMode,
            );
        }
        impl Conv2DKey {
            #[inline]
            pub unsafe fn new(
                arg1: root::taso::Tensor,
                arg2: root::taso::Tensor,
                arg3: ::std::os::raw::c_int,
                arg4: ::std::os::raw::c_int,
                arg5: root::taso::PaddingMode,
                arg6: root::taso::ActiMode,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Conv2DKey_Conv2DKey(
                    __bindgen_tmp.as_mut_ptr(),
                    arg1,
                    arg2,
                    arg3,
                    arg4,
                    arg5,
                    arg6,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ElementKey {
            pub keys: [::std::os::raw::c_int; 549usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10ElementKey10KEY_LENGTHE"]
            pub static ElementKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_ElementKey() {
            assert_eq!(
                ::std::mem::size_of::<ElementKey>(),
                2196usize,
                concat!("Size of: ", stringify!(ElementKey))
            );
            assert_eq!(
                ::std::mem::align_of::<ElementKey>(),
                4usize,
                concat!("Alignment of ", stringify!(ElementKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ElementKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ElementKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10ElementKeyC1ERKNS_6TensorES3_NS_6OpTypeE"]
            pub fn ElementKey_ElementKey(
                this: *mut root::taso::ElementKey,
                t1: *const root::taso::Tensor,
                t2: *const root::taso::Tensor,
                type_: root::taso::OpType,
            );
        }
        impl ElementKey {
            #[inline]
            pub unsafe fn new(
                t1: *const root::taso::Tensor,
                t2: *const root::taso::Tensor,
                type_: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ElementKey_ElementKey(__bindgen_tmp.as_mut_ptr(), t1, t2, type_);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ElementWiseUnaryKey {
            pub keys: [::std::os::raw::c_int; 275usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso19ElementWiseUnaryKey10KEY_LENGTHE"]
            pub static ElementWiseUnaryKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_ElementWiseUnaryKey() {
            assert_eq!(
                ::std::mem::size_of::<ElementWiseUnaryKey>(),
                1100usize,
                concat!("Size of: ", stringify!(ElementWiseUnaryKey))
            );
            assert_eq!(
                ::std::mem::align_of::<ElementWiseUnaryKey>(),
                4usize,
                concat!("Alignment of ", stringify!(ElementWiseUnaryKey))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ElementWiseUnaryKey>())).keys as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ElementWiseUnaryKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso19ElementWiseUnaryKeyC1ERKNS_6TensorENS_6OpTypeE"]
            pub fn ElementWiseUnaryKey_ElementWiseUnaryKey(
                this: *mut root::taso::ElementWiseUnaryKey,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            );
        }
        impl ElementWiseUnaryKey {
            #[inline]
            pub unsafe fn new(
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ElementWiseUnaryKey_ElementWiseUnaryKey(__bindgen_tmp.as_mut_ptr(), _input, _type);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct EnlargeKey {
            pub keys: [::std::os::raw::c_int; 548usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10EnlargeKey10KEY_LENGTHE"]
            pub static EnlargeKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_EnlargeKey() {
            assert_eq!(
                ::std::mem::size_of::<EnlargeKey>(),
                2192usize,
                concat!("Size of: ", stringify!(EnlargeKey))
            );
            assert_eq!(
                ::std::mem::align_of::<EnlargeKey>(),
                4usize,
                concat!("Alignment of ", stringify!(EnlargeKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<EnlargeKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(EnlargeKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10EnlargeKeyC1ENS_6TensorES1_"]
            pub fn EnlargeKey_EnlargeKey(
                this: *mut root::taso::EnlargeKey,
                w1: root::taso::Tensor,
                w2: root::taso::Tensor,
            );
        }
        impl EnlargeKey {
            #[inline]
            pub unsafe fn new(w1: root::taso::Tensor, w2: root::taso::Tensor) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                EnlargeKey_EnlargeKey(__bindgen_tmp.as_mut_ptr(), w1, w2);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct TopKKey {
            pub keys: [::std::os::raw::c_int; 278usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7TopKKey10KEY_LENGTHE"]
            pub static TopKKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_TopKKey() {
            assert_eq!(
                ::std::mem::size_of::<TopKKey>(),
                1112usize,
                concat!("Size of: ", stringify!(TopKKey))
            );
            assert_eq!(
                ::std::mem::align_of::<TopKKey>(),
                4usize,
                concat!("Alignment of ", stringify!(TopKKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TopKKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TopKKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7TopKKeyC1ERKNS_6TensorEiibb"]
            pub fn TopKKey_TopKKey(
                this: *mut root::taso::TopKKey,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
            );
        }
        impl TopKKey {
            #[inline]
            pub unsafe fn new(
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                TopKKey_TopKKey(
                    __bindgen_tmp.as_mut_ptr(),
                    _input,
                    _axis,
                    _numk,
                    _largest,
                    _sorted,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct MatmulKey {
            pub keys: [::std::os::raw::c_int; 549usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9MatmulKey10KEY_LENGTHE"]
            pub static MatmulKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_MatmulKey() {
            assert_eq!(
                ::std::mem::size_of::<MatmulKey>(),
                2196usize,
                concat!("Size of: ", stringify!(MatmulKey))
            );
            assert_eq!(
                ::std::mem::align_of::<MatmulKey>(),
                4usize,
                concat!("Alignment of ", stringify!(MatmulKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<MatmulKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MatmulKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9MatmulKeyC1ENS_6TensorES1_NS_8ActiModeE"]
            pub fn MatmulKey_MatmulKey(
                this: *mut root::taso::MatmulKey,
                arg1: root::taso::Tensor,
                arg2: root::taso::Tensor,
                arg3: root::taso::ActiMode,
            );
        }
        impl MatmulKey {
            #[inline]
            pub unsafe fn new(
                arg1: root::taso::Tensor,
                arg2: root::taso::Tensor,
                arg3: root::taso::ActiMode,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                MatmulKey_MatmulKey(__bindgen_tmp.as_mut_ptr(), arg1, arg2, arg3);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct MergeGConvKey {
            pub keys: [::std::os::raw::c_int; 275usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso13MergeGConvKey10KEY_LENGTHE"]
            pub static MergeGConvKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_MergeGConvKey() {
            assert_eq!(
                ::std::mem::size_of::<MergeGConvKey>(),
                1100usize,
                concat!("Size of: ", stringify!(MergeGConvKey))
            );
            assert_eq!(
                ::std::mem::align_of::<MergeGConvKey>(),
                4usize,
                concat!("Alignment of ", stringify!(MergeGConvKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<MergeGConvKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MergeGConvKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso13MergeGConvKeyC1ERKNS_6TensorEi"]
            pub fn MergeGConvKey_MergeGConvKey(
                this: *mut root::taso::MergeGConvKey,
                weight: *const root::taso::Tensor,
                count: ::std::os::raw::c_int,
            );
        }
        impl MergeGConvKey {
            #[inline]
            pub unsafe fn new(
                weight: *const root::taso::Tensor,
                count: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                MergeGConvKey_MergeGConvKey(__bindgen_tmp.as_mut_ptr(), weight, count);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct MulKey {
            pub keys: [::std::os::raw::c_int; 548usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6MulKey10KEY_LENGTHE"]
            pub static MulKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_MulKey() {
            assert_eq!(
                ::std::mem::size_of::<MulKey>(),
                2192usize,
                concat!("Size of: ", stringify!(MulKey))
            );
            assert_eq!(
                ::std::mem::align_of::<MulKey>(),
                4usize,
                concat!("Alignment of ", stringify!(MulKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<MulKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MulKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6MulKeyC1ERKNS_6TensorES3_"]
            pub fn MulKey_MulKey(
                this: *mut root::taso::MulKey,
                arg1: *const root::taso::Tensor,
                arg2: *const root::taso::Tensor,
            );
        }
        impl MulKey {
            #[inline]
            pub unsafe fn new(
                arg1: *const root::taso::Tensor,
                arg2: *const root::taso::Tensor,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                MulKey_MulKey(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct NoopKey {
            pub keys: [::std::os::raw::c_int; 275usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7NoopKey10KEY_LENGTHE"]
            pub static NoopKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_NoopKey() {
            assert_eq!(
                ::std::mem::size_of::<NoopKey>(),
                1100usize,
                concat!("Size of: ", stringify!(NoopKey))
            );
            assert_eq!(
                ::std::mem::align_of::<NoopKey>(),
                4usize,
                concat!("Alignment of ", stringify!(NoopKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<NoopKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NoopKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7NoopKeyC1ENS_6TensorENS_6OpTypeE"]
            pub fn NoopKey_NoopKey(
                this: *mut root::taso::NoopKey,
                input: root::taso::Tensor,
                typee: root::taso::OpType,
            );
        }
        impl NoopKey {
            #[inline]
            pub unsafe fn new(input: root::taso::Tensor, typee: root::taso::OpType) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                NoopKey_NoopKey(__bindgen_tmp.as_mut_ptr(), input, typee);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct PadKey {
            pub keys: [::std::os::raw::c_int; 291usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6PadKey10KEY_LENGTHE"]
            pub static PadKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_PadKey() {
            assert_eq!(
                ::std::mem::size_of::<PadKey>(),
                1164usize,
                concat!("Size of: ", stringify!(PadKey))
            );
            assert_eq!(
                ::std::mem::align_of::<PadKey>(),
                4usize,
                concat!("Alignment of ", stringify!(PadKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<PadKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PadKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6PadKeyC1ERKNS_6TensorERKSt6vectorIiSaIiEES8_f"]
            pub fn PadKey_PadKey(
                this: *mut root::taso::PadKey,
                _input: *const root::taso::Tensor,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            );
        }
        impl PadKey {
            #[inline]
            pub unsafe fn new(
                _input: *const root::taso::Tensor,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PadKey_PadKey(
                    __bindgen_tmp.as_mut_ptr(),
                    _input,
                    _pad_before,
                    _pad_after,
                    _pad_value,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Pool2DKey {
            pub keys: [::std::os::raw::c_int; 281usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Pool2DKey10KEY_LENGTHE"]
            pub static Pool2DKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_Pool2DKey() {
            assert_eq!(
                ::std::mem::size_of::<Pool2DKey>(),
                1124usize,
                concat!("Size of: ", stringify!(Pool2DKey))
            );
            assert_eq!(
                ::std::mem::align_of::<Pool2DKey>(),
                4usize,
                concat!("Alignment of ", stringify!(Pool2DKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2DKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2DKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Pool2DKeyC1ENS_6TensorENS_6OpTypeEiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Pool2DKey_Pool2DKey(
                this: *mut root::taso::Pool2DKey,
                arg1: root::taso::Tensor,
                arg2: root::taso::OpType,
                arg3: ::std::os::raw::c_int,
                arg4: ::std::os::raw::c_int,
                arg5: ::std::os::raw::c_int,
                arg6: ::std::os::raw::c_int,
                arg7: root::taso::PaddingMode,
                arg8: root::taso::ActiMode,
            );
        }
        impl Pool2DKey {
            #[inline]
            pub unsafe fn new(
                arg1: root::taso::Tensor,
                arg2: root::taso::OpType,
                arg3: ::std::os::raw::c_int,
                arg4: ::std::os::raw::c_int,
                arg5: ::std::os::raw::c_int,
                arg6: ::std::os::raw::c_int,
                arg7: root::taso::PaddingMode,
                arg8: root::taso::ActiMode,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Pool2DKey_Pool2DKey(
                    __bindgen_tmp.as_mut_ptr(),
                    arg1,
                    arg2,
                    arg3,
                    arg4,
                    arg5,
                    arg6,
                    arg7,
                    arg8,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ReduceKey {
            pub keys: [::std::os::raw::c_int; 285usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9ReduceKey10KEY_LENGTHE"]
            pub static ReduceKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_ReduceKey() {
            assert_eq!(
                ::std::mem::size_of::<ReduceKey>(),
                1140usize,
                concat!("Size of: ", stringify!(ReduceKey))
            );
            assert_eq!(
                ::std::mem::align_of::<ReduceKey>(),
                4usize,
                concat!("Alignment of ", stringify!(ReduceKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ReduceKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReduceKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9ReduceKeyC1ERKNS_6TensorENS_6OpTypeERKSt6vectorIiSaIiEEb"]
            pub fn ReduceKey_ReduceKey(
                this: *mut root::taso::ReduceKey,
                arg1: *const root::taso::Tensor,
                arg2: root::taso::OpType,
                arg3: *const [u64; 3usize],
                arg4: bool,
            );
        }
        impl ReduceKey {
            #[inline]
            pub unsafe fn new(
                arg1: *const root::taso::Tensor,
                arg2: root::taso::OpType,
                arg3: *const [u64; 3usize],
                arg4: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ReduceKey_ReduceKey(__bindgen_tmp.as_mut_ptr(), arg1, arg2, arg3, arg4);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ReshapeKey {
            pub keys: [::std::os::raw::c_int; 283usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10ReshapeKey10KEY_LENGTHE"]
            pub static ReshapeKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_ReshapeKey() {
            assert_eq!(
                ::std::mem::size_of::<ReshapeKey>(),
                1132usize,
                concat!("Size of: ", stringify!(ReshapeKey))
            );
            assert_eq!(
                ::std::mem::align_of::<ReshapeKey>(),
                4usize,
                concat!("Alignment of ", stringify!(ReshapeKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ReshapeKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReshapeKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10ReshapeKeyC1ENS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn ReshapeKey_ReshapeKey(
                this: *mut root::taso::ReshapeKey,
                arg1: root::taso::Tensor,
                arg2: *const [u64; 3usize],
            );
        }
        impl ReshapeKey {
            #[inline]
            pub unsafe fn new(arg1: root::taso::Tensor, arg2: *const [u64; 3usize]) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ReshapeKey_ReshapeKey(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ResizeKey {
            pub keys: [::std::os::raw::c_int; 283usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9ResizeKey10KEY_LENGTHE"]
            pub static ResizeKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_ResizeKey() {
            assert_eq!(
                ::std::mem::size_of::<ResizeKey>(),
                1132usize,
                concat!("Size of: ", stringify!(ResizeKey))
            );
            assert_eq!(
                ::std::mem::align_of::<ResizeKey>(),
                4usize,
                concat!("Alignment of ", stringify!(ResizeKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ResizeKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ResizeKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9ResizeKeyC1ERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn ResizeKey_ResizeKey(
                this: *mut root::taso::ResizeKey,
                arg1: *const root::taso::Tensor,
                arg2: *const [u64; 3usize],
            );
        }
        impl ResizeKey {
            #[inline]
            pub unsafe fn new(arg1: *const root::taso::Tensor, arg2: *const [u64; 3usize]) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ResizeKey_ResizeKey(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ShapeKey {
            pub keys: [::std::os::raw::c_int; 275usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8ShapeKey10KEY_LENGTHE"]
            pub static ShapeKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_ShapeKey() {
            assert_eq!(
                ::std::mem::size_of::<ShapeKey>(),
                1100usize,
                concat!("Size of: ", stringify!(ShapeKey))
            );
            assert_eq!(
                ::std::mem::align_of::<ShapeKey>(),
                4usize,
                concat!("Alignment of ", stringify!(ShapeKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ShapeKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ShapeKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8ShapeKeyC1ERKNS_6TensorENS_6OpTypeE"]
            pub fn ShapeKey_ShapeKey(
                this: *mut root::taso::ShapeKey,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            );
        }
        impl ShapeKey {
            #[inline]
            pub unsafe fn new(
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ShapeKey_ShapeKey(__bindgen_tmp.as_mut_ptr(), _input, _type);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct SliceKey {
            pub keys: [::std::os::raw::c_int; 307usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8SliceKey10KEY_LENGTHE"]
            pub static SliceKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_SliceKey() {
            assert_eq!(
                ::std::mem::size_of::<SliceKey>(),
                1228usize,
                concat!("Size of: ", stringify!(SliceKey))
            );
            assert_eq!(
                ::std::mem::align_of::<SliceKey>(),
                4usize,
                concat!("Alignment of ", stringify!(SliceKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SliceKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SliceKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8SliceKeyC1ERKNS_6TensorERKSt6vectorIiSaIiEES8_S8_S8_"]
            pub fn SliceKey_SliceKey(
                this: *mut root::taso::SliceKey,
                _input: *const root::taso::Tensor,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            );
        }
        impl SliceKey {
            #[inline]
            pub unsafe fn new(
                _input: *const root::taso::Tensor,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SliceKey_SliceKey(
                    __bindgen_tmp.as_mut_ptr(),
                    _input,
                    _start,
                    _end,
                    _axes,
                    _steps,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct SqueezeKey {
            pub keys: [::std::os::raw::c_int; 282usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10SqueezeKey10KEY_LENGTHE"]
            pub static SqueezeKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_SqueezeKey() {
            assert_eq!(
                ::std::mem::size_of::<SqueezeKey>(),
                1128usize,
                concat!("Size of: ", stringify!(SqueezeKey))
            );
            assert_eq!(
                ::std::mem::align_of::<SqueezeKey>(),
                4usize,
                concat!("Alignment of ", stringify!(SqueezeKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SqueezeKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SqueezeKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10SqueezeKeyC1ERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn SqueezeKey_SqueezeKey(
                this: *mut root::taso::SqueezeKey,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            );
        }
        impl SqueezeKey {
            #[inline]
            pub unsafe fn new(
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SqueezeKey_SqueezeKey(__bindgen_tmp.as_mut_ptr(), input, axes);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct SplitKey {
            pub keys: [::std::os::raw::c_int; 282usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8SplitKey10KEY_LENGTHE"]
            pub static SplitKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_SplitKey() {
            assert_eq!(
                ::std::mem::size_of::<SplitKey>(),
                1128usize,
                concat!("Size of: ", stringify!(SplitKey))
            );
            assert_eq!(
                ::std::mem::align_of::<SplitKey>(),
                4usize,
                concat!("Alignment of ", stringify!(SplitKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SplitKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SplitKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8SplitKeyC1ERKNS_6TensorEiRKSt6vectorIiSaIiEE"]
            pub fn SplitKey_SplitKey(
                this: *mut root::taso::SplitKey,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
            );
        }
        impl SplitKey {
            #[inline]
            pub unsafe fn new(
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SplitKey_SplitKey(__bindgen_tmp.as_mut_ptr(), _input, _axis, _sizes);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct TransposeKey {
            pub keys: [::std::os::raw::c_int; 276usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso12TransposeKey10KEY_LENGTHE"]
            pub static TransposeKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_TransposeKey() {
            assert_eq!(
                ::std::mem::size_of::<TransposeKey>(),
                1104usize,
                concat!("Size of: ", stringify!(TransposeKey))
            );
            assert_eq!(
                ::std::mem::align_of::<TransposeKey>(),
                4usize,
                concat!("Alignment of ", stringify!(TransposeKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TransposeKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransposeKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso12TransposeKeyC1ENS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn TransposeKey_TransposeKey(
                this: *mut root::taso::TransposeKey,
                arg1: root::taso::Tensor,
                arg2: *const [u64; 3usize],
                arg3: bool,
            );
        }
        impl TransposeKey {
            #[inline]
            pub unsafe fn new(
                arg1: root::taso::Tensor,
                arg2: *const [u64; 3usize],
                arg3: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                TransposeKey_TransposeKey(__bindgen_tmp.as_mut_ptr(), arg1, arg2, arg3);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct UnsqueezeKey {
            pub keys: [::std::os::raw::c_int; 282usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso12UnsqueezeKey10KEY_LENGTHE"]
            pub static UnsqueezeKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_UnsqueezeKey() {
            assert_eq!(
                ::std::mem::size_of::<UnsqueezeKey>(),
                1128usize,
                concat!("Size of: ", stringify!(UnsqueezeKey))
            );
            assert_eq!(
                ::std::mem::align_of::<UnsqueezeKey>(),
                4usize,
                concat!("Alignment of ", stringify!(UnsqueezeKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<UnsqueezeKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnsqueezeKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso12UnsqueezeKeyC1ERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn UnsqueezeKey_UnsqueezeKey(
                this: *mut root::taso::UnsqueezeKey,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            );
        }
        impl UnsqueezeKey {
            #[inline]
            pub unsafe fn new(
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                UnsqueezeKey_UnsqueezeKey(__bindgen_tmp.as_mut_ptr(), input, axes);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct WhereKey {
            pub keys: [::std::os::raw::c_int; 822usize],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8WhereKey10KEY_LENGTHE"]
            pub static WhereKey_KEY_LENGTH: ::std::os::raw::c_int;
        }
        #[test]
        fn bindgen_test_layout_WhereKey() {
            assert_eq!(
                ::std::mem::size_of::<WhereKey>(),
                3288usize,
                concat!("Size of: ", stringify!(WhereKey))
            );
            assert_eq!(
                ::std::mem::align_of::<WhereKey>(),
                4usize,
                concat!("Alignment of ", stringify!(WhereKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<WhereKey>())).keys as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WhereKey),
                    "::",
                    stringify!(keys)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso8WhereKeyC1ERKNS_6TensorES3_S3_"]
            pub fn WhereKey_WhereKey(
                this: *mut root::taso::WhereKey,
                _cond: *const root::taso::Tensor,
                _x: *const root::taso::Tensor,
                _y: *const root::taso::Tensor,
            );
        }
        impl WhereKey {
            #[inline]
            pub unsafe fn new(
                _cond: *const root::taso::Tensor,
                _x: *const root::taso::Tensor,
                _y: *const root::taso::Tensor,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                WhereKey_WhereKey(__bindgen_tmp.as_mut_ptr(), _cond, _x, _y);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Model {
            pub isTraining: bool,
            pub print_cost: bool,
            pub global_unique_id: root::size_t,
            pub workSpaceSize: root::size_t,
            pub workSpace: *mut ::std::os::raw::c_void,
            pub activation: [u64; 6usize],
            pub batchnorm: [u64; 6usize],
            pub cast: [u64; 6usize],
            pub concat: [u64; 6usize],
            pub constant: [u64; 6usize],
            pub conv2d: [u64; 6usize],
            pub element: [u64; 6usize],
            pub element_unary: [u64; 6usize],
            pub enlarge: [u64; 6usize],
            pub matmul: [u64; 6usize],
            pub merge_gconv: [u64; 6usize],
            pub mul: [u64; 6usize],
            pub noop: [u64; 6usize],
            pub pad: [u64; 6usize],
            pub pool2d: [u64; 6usize],
            pub reduce: [u64; 6usize],
            pub reshape: [u64; 6usize],
            pub resize: [u64; 6usize],
            pub shape: [u64; 6usize],
            pub slice: [u64; 6usize],
            pub split: [u64; 6usize],
            pub squeeze: [u64; 6usize],
            pub topk: [u64; 6usize],
            pub transpose: [u64; 6usize],
            pub unsqueeze: [u64; 6usize],
            pub where_: [u64; 6usize],
            pub inputPtr: *mut root::taso::DATATYPE,
            pub biasPtr: *mut root::taso::DATATYPE,
            pub outputPtr: *mut root::taso::DATATYPE,
            pub filterPtr: *mut root::taso::DATATYPE,
            pub scalePtr: *mut root::taso::DATATYPE,
            pub runningMean: *mut root::taso::DATATYPE,
            pub runningVar: *mut root::taso::DATATYPE,
            pub saveMean: *mut root::taso::DATATYPE,
            pub saveVar: *mut root::taso::DATATYPE,
        }
        #[test]
        fn bindgen_test_layout_Model() {
            assert_eq!(
                ::std::mem::size_of::<Model>(),
                1352usize,
                concat!("Size of: ", stringify!(Model))
            );
            assert_eq!(
                ::std::mem::align_of::<Model>(),
                8usize,
                concat!("Alignment of ", stringify!(Model))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).isTraining as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(isTraining)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).print_cost as *const _ as usize },
                1usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(print_cost)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).global_unique_id as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(global_unique_id)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).workSpaceSize as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(workSpaceSize)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).workSpace as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(workSpace)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).activation as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(activation)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).batchnorm as *const _ as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(batchnorm)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).cast as *const _ as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(cast)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).concat as *const _ as usize },
                176usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(concat)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).constant as *const _ as usize },
                224usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(constant)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).conv2d as *const _ as usize },
                272usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(conv2d)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).element as *const _ as usize },
                320usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(element)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).element_unary as *const _ as usize },
                368usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(element_unary)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).enlarge as *const _ as usize },
                416usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(enlarge)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).matmul as *const _ as usize },
                464usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(matmul)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).merge_gconv as *const _ as usize },
                512usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(merge_gconv)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).mul as *const _ as usize },
                560usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(mul)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).noop as *const _ as usize },
                608usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(noop)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).pad as *const _ as usize },
                656usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(pad)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).pool2d as *const _ as usize },
                704usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(pool2d)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).reduce as *const _ as usize },
                752usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(reduce)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).reshape as *const _ as usize },
                800usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(reshape)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).resize as *const _ as usize },
                848usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(resize)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).shape as *const _ as usize },
                896usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(shape)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).slice as *const _ as usize },
                944usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(slice)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).split as *const _ as usize },
                992usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(split)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).squeeze as *const _ as usize },
                1040usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(squeeze)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).topk as *const _ as usize },
                1088usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(topk)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).transpose as *const _ as usize },
                1136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(transpose)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).unsqueeze as *const _ as usize },
                1184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(unsqueeze)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).where_ as *const _ as usize },
                1232usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(where_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).inputPtr as *const _ as usize },
                1280usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(inputPtr)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).biasPtr as *const _ as usize },
                1288usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(biasPtr)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).outputPtr as *const _ as usize },
                1296usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(outputPtr)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).filterPtr as *const _ as usize },
                1304usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(filterPtr)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).scalePtr as *const _ as usize },
                1312usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(scalePtr)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).runningMean as *const _ as usize },
                1320usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(runningMean)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).runningVar as *const _ as usize },
                1328usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(runningVar)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).saveMean as *const _ as usize },
                1336usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(saveMean)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Model>())).saveVar as *const _ as usize },
                1344usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Model),
                    "::",
                    stringify!(saveVar)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model24get_or_create_activationENS_6TensorENS_6OpTypeEb"]
            pub fn Model_get_or_create_activation(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
                _inPlace: bool,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model23get_or_create_batchnormENS_6TensorES1_S1_S1_S1_"]
            pub fn Model_get_or_create_batchnorm(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _scale: root::taso::Tensor,
                _bias: root::taso::Tensor,
                _mean: root::taso::Tensor,
                _var: root::taso::Tensor,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18get_or_create_castERKNS_6TensorENS_8DataTypeE"]
            pub fn Model_get_or_create_cast(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _datatype: root::taso::DataType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20get_or_create_concatEiiPNS_6TensorEPb"]
            pub fn Model_get_or_create_concat(
                this: *mut root::taso::Model,
                axis: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
                _inputs: *mut root::taso::Tensor,
                _needCopy: *mut bool,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model22get_or_create_constantEiPiNS_6OpTypeE"]
            pub fn Model_get_or_create_constant(
                this: *mut root::taso::Model,
                ndim: ::std::os::raw::c_int,
                dims: *mut ::std::os::raw::c_int,
                type_: root::taso::OpType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20get_or_create_conv2dENS_6TensorES1_iiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Model_get_or_create_conv2d(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model21get_or_create_elementENS_6OpTypeERKNS_6TensorES4_"]
            pub fn Model_get_or_create_element(
                this: *mut root::taso::Model,
                type_: root::taso::OpType,
                t1: *const root::taso::Tensor,
                t2: *const root::taso::Tensor,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model31get_or_create_elementwise_unaryERKNS_6TensorENS_6OpTypeE"]
            pub fn Model_get_or_create_elementwise_unary(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model21get_or_create_enlargeENS_6TensorES1_"]
            pub fn Model_get_or_create_enlarge(
                this: *mut root::taso::Model,
                _w1: root::taso::Tensor,
                _w2: root::taso::Tensor,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20get_or_create_matmulENS_6TensorES1_NS_8ActiModeE"]
            pub fn Model_get_or_create_matmul(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _actimode: root::taso::ActiMode,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model17get_or_create_mulERKNS_6TensorES3_"]
            pub fn Model_get_or_create_mul(
                this: *mut root::taso::Model,
                x: *const root::taso::Tensor,
                y: *const root::taso::Tensor,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model17get_or_create_padERKNS_6TensorERKSt6vectorIiSaIiEES8_f"]
            pub fn Model_get_or_create_pad(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20get_or_create_pool2dENS_6TensorES1_NS_6OpTypeEiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Model_get_or_create_pool2d(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _type: root::taso::OpType,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20get_or_create_reduceERKNS_6TensorENS_6OpTypeERKSt6vectorIiSaIiEEb"]
            pub fn Model_get_or_create_reduce(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
                _axes: *const [u64; 3usize],
                _keepdims: bool,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model21get_or_create_reshapeENS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Model_get_or_create_reshape(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                shape: *const [u64; 3usize],
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20get_or_create_resizeERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Model_get_or_create_resize(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _shape: *const [u64; 3usize],
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19get_or_create_shapeERKNS_6TensorENS_6OpTypeE"]
            pub fn Model_get_or_create_shape(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19get_or_create_sliceERKNS_6TensorERKSt6vectorIiSaIiEES8_S8_S8_"]
            pub fn Model_get_or_create_slice(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model21get_or_create_squeezeERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Model_get_or_create_squeeze(
                this: *mut root::taso::Model,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19get_or_create_splitERKNS_6TensorEiRKSt6vectorIiSaIiEE"]
            pub fn Model_get_or_create_split(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19get_or_create_splitERKNS_6TensorEii"]
            pub fn Model_get_or_create_split1(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                axis: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18get_or_create_topkERKNS_6TensorEiibb"]
            pub fn Model_get_or_create_topk(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model23get_or_create_transposeENS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Model_get_or_create_transpose(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _perm: *const [u64; 3usize],
                _shuffle: bool,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model23get_or_create_transposeENS_6TensorEib"]
            pub fn Model_get_or_create_transpose1(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                permIdx: ::std::os::raw::c_int,
                _shuffle: bool,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18get_or_create_noopENS_6TensorENS_6OpTypeE"]
            pub fn Model_get_or_create_noop(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model25get_or_create_merge_gconvERKNS_6TensorEi"]
            pub fn Model_get_or_create_merge_gconv(
                this: *mut root::taso::Model,
                _weight: *const root::taso::Tensor,
                count: ::std::os::raw::c_int,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model23get_or_create_unsqueezeERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Model_get_or_create_unsqueeze(
                this: *mut root::taso::Model,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19get_or_create_whereERKNS_6TensorES3_S3_"]
            pub fn Model_get_or_create_where(
                this: *mut root::taso::Model,
                _cond: *const root::taso::Tensor,
                _x: *const root::taso::Tensor,
                _y: *const root::taso::Tensor,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model12create_inputENS_6TensorENS_6OpTypeE"]
            pub fn Model_create_input(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model13create_weightENS_6TensorENS_6OpTypeE"]
            pub fn Model_create_weight(
                this: *mut root::taso::Model,
                _weight: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19measure_conv2d_costEPNS_6Conv2DE"]
            pub fn Model_measure_conv2d_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Conv2D,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19measure_matmul_costEPNS_6MatmulE"]
            pub fn Model_measure_matmul_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Matmul,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model16measure_mul_costEPNS_3MulE"]
            pub fn Model_measure_mul_cost(this: *mut root::taso::Model, arg1: *mut root::taso::Mul);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model16measure_pad_costEPNS_3PadE"]
            pub fn Model_measure_pad_cost(this: *mut root::taso::Model, arg1: *mut root::taso::Pad);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19measure_pool2d_costEPNS_6Pool2DE"]
            pub fn Model_measure_pool2d_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Pool2D,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model17measure_topk_costEPNS_4TopKE"]
            pub fn Model_measure_topk_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::TopK,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model22measure_transpose_costEPNS_9TransposeE"]
            pub fn Model_measure_transpose_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Transpose,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19measure_reduce_costEPNS_6ReduceE"]
            pub fn Model_measure_reduce_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Reduce,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20measure_reshape_costEPNS_7ReshapeE"]
            pub fn Model_measure_reshape_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Reshape,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19measure_resize_costEPNS_6ResizeE"]
            pub fn Model_measure_resize_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Resize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model23measure_activation_costEPNS_10ActivationE"]
            pub fn Model_measure_activation_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Activation,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model22measure_batchnorm_costEPNS_9BatchNormE"]
            pub fn Model_measure_batchnorm_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::BatchNorm,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model17measure_cast_costEPNS_4CastE"]
            pub fn Model_measure_cast_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Cast,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19measure_concat_costEPNS_6ConcatE"]
            pub fn Model_measure_concat_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Concat,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18measure_shape_costEPNS_5ShapeE"]
            pub fn Model_measure_shape_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Shape,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18measure_slice_costEPNS_5SliceE"]
            pub fn Model_measure_slice_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Slice,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18measure_split_costEPNS_5SplitE"]
            pub fn Model_measure_split_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Split,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20measure_element_costEPNS_7ElementE"]
            pub fn Model_measure_element_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Element,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model30measure_elementwise_unary_costEPNS_16ElementWiseUnaryE"]
            pub fn Model_measure_elementwise_unary_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::ElementWiseUnary,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20measure_enlarge_costEPNS_7EnlargeE"]
            pub fn Model_measure_enlarge_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Enlarge,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20measure_squeeze_costEPNS_7SqueezeE"]
            pub fn Model_measure_squeeze_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Squeeze,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model22measure_unsqueeze_costEPNS_9UnsqueezeE"]
            pub fn Model_measure_unsqueeze_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Unsqueeze,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18measure_where_costEPNS_5WhereE"]
            pub fn Model_measure_where_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Where,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model15allocate_memoryEmPKf"]
            pub fn Model_allocate_memory(
                this: *mut root::taso::Model,
                size: root::size_t,
                initial_data: *const root::taso::DATATYPE,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model11copy_memoryEPfPKfm"]
            pub fn Model_copy_memory(
                this: *mut root::taso::Model,
                dst: *mut root::taso::DATATYPE,
                src: *const root::taso::DATATYPE,
                size: root::size_t,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model22measure_oplist_runtimeERKSt6vectorIPNS_6OpBaseESaIS3_EE"]
            pub fn Model_measure_oplist_runtime(
                this: *mut root::taso::Model,
                list: *const u8,
            ) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model13broadcastableERKNS_6TensorES3_"]
            pub fn Model_broadcastable(
                this: *mut root::taso::Model,
                t1: *const root::taso::Tensor,
                t2: *const root::taso::Tensor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5ModelC1Ev"]
            pub fn Model_Model(this: *mut root::taso::Model);
        }
        impl Model {
            #[inline]
            pub unsafe fn get_or_create_activation(
                &mut self,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
                _inPlace: bool,
            ) -> root::taso::Op {
                Model_get_or_create_activation(self, _input, _type, _inPlace)
            }
            #[inline]
            pub unsafe fn get_or_create_batchnorm(
                &mut self,
                _input: root::taso::Tensor,
                _scale: root::taso::Tensor,
                _bias: root::taso::Tensor,
                _mean: root::taso::Tensor,
                _var: root::taso::Tensor,
            ) -> root::taso::Op {
                Model_get_or_create_batchnorm(self, _input, _scale, _bias, _mean, _var)
            }
            #[inline]
            pub unsafe fn get_or_create_cast(
                &mut self,
                _input: *const root::taso::Tensor,
                _datatype: root::taso::DataType,
            ) -> root::taso::Op {
                Model_get_or_create_cast(self, _input, _datatype)
            }
            #[inline]
            pub unsafe fn get_or_create_concat(
                &mut self,
                axis: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
                _inputs: *mut root::taso::Tensor,
                _needCopy: *mut bool,
            ) -> root::taso::Op {
                Model_get_or_create_concat(self, axis, n, _inputs, _needCopy)
            }
            #[inline]
            pub unsafe fn get_or_create_constant(
                &mut self,
                ndim: ::std::os::raw::c_int,
                dims: *mut ::std::os::raw::c_int,
                type_: root::taso::OpType,
            ) -> root::taso::Op {
                Model_get_or_create_constant(self, ndim, dims, type_)
            }
            #[inline]
            pub unsafe fn get_or_create_conv2d(
                &mut self,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::Op {
                Model_get_or_create_conv2d(
                    self,
                    _input,
                    _weight,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn get_or_create_element(
                &mut self,
                type_: root::taso::OpType,
                t1: *const root::taso::Tensor,
                t2: *const root::taso::Tensor,
            ) -> root::taso::Op {
                Model_get_or_create_element(self, type_, t1, t2)
            }
            #[inline]
            pub unsafe fn get_or_create_elementwise_unary(
                &mut self,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op {
                Model_get_or_create_elementwise_unary(self, _input, _type)
            }
            #[inline]
            pub unsafe fn get_or_create_enlarge(
                &mut self,
                _w1: root::taso::Tensor,
                _w2: root::taso::Tensor,
            ) -> root::taso::Op {
                Model_get_or_create_enlarge(self, _w1, _w2)
            }
            #[inline]
            pub unsafe fn get_or_create_matmul(
                &mut self,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _actimode: root::taso::ActiMode,
            ) -> root::taso::Op {
                Model_get_or_create_matmul(self, _input, _weight, _actimode)
            }
            #[inline]
            pub unsafe fn get_or_create_mul(
                &mut self,
                x: *const root::taso::Tensor,
                y: *const root::taso::Tensor,
            ) -> root::taso::Op {
                Model_get_or_create_mul(self, x, y)
            }
            #[inline]
            pub unsafe fn get_or_create_pad(
                &mut self,
                _input: *const root::taso::Tensor,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            ) -> root::taso::Op {
                Model_get_or_create_pad(self, _input, _pad_before, _pad_after, _pad_value)
            }
            #[inline]
            pub unsafe fn get_or_create_pool2d(
                &mut self,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _type: root::taso::OpType,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::Op {
                Model_get_or_create_pool2d(
                    self,
                    _input,
                    _weight,
                    _type,
                    _kernelH,
                    _kernelW,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn get_or_create_reduce(
                &mut self,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
                _axes: *const [u64; 3usize],
                _keepdims: bool,
            ) -> root::taso::Op {
                Model_get_or_create_reduce(self, _input, _type, _axes, _keepdims)
            }
            #[inline]
            pub unsafe fn get_or_create_reshape(
                &mut self,
                _input: root::taso::Tensor,
                shape: *const [u64; 3usize],
            ) -> root::taso::Op {
                Model_get_or_create_reshape(self, _input, shape)
            }
            #[inline]
            pub unsafe fn get_or_create_resize(
                &mut self,
                _input: *const root::taso::Tensor,
                _shape: *const [u64; 3usize],
            ) -> root::taso::Op {
                Model_get_or_create_resize(self, _input, _shape)
            }
            #[inline]
            pub unsafe fn get_or_create_shape(
                &mut self,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op {
                Model_get_or_create_shape(self, _input, _type)
            }
            #[inline]
            pub unsafe fn get_or_create_slice(
                &mut self,
                _input: *const root::taso::Tensor,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            ) -> root::taso::Op {
                Model_get_or_create_slice(self, _input, _start, _end, _axes, _steps)
            }
            #[inline]
            pub unsafe fn get_or_create_squeeze(
                &mut self,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> root::taso::Op {
                Model_get_or_create_squeeze(self, input, axes)
            }
            #[inline]
            pub unsafe fn get_or_create_split(
                &mut self,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
            ) -> root::taso::Op {
                Model_get_or_create_split(self, _input, _axis, _sizes)
            }
            #[inline]
            pub unsafe fn get_or_create_split1(
                &mut self,
                _input: *const root::taso::Tensor,
                axis: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
            ) -> root::taso::Op {
                Model_get_or_create_split1(self, _input, axis, n)
            }
            #[inline]
            pub unsafe fn get_or_create_topk(
                &mut self,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
            ) -> root::taso::Op {
                Model_get_or_create_topk(self, _input, _axis, _numk, _largest, _sorted)
            }
            #[inline]
            pub unsafe fn get_or_create_transpose(
                &mut self,
                _input: root::taso::Tensor,
                _perm: *const [u64; 3usize],
                _shuffle: bool,
            ) -> root::taso::Op {
                Model_get_or_create_transpose(self, _input, _perm, _shuffle)
            }
            #[inline]
            pub unsafe fn get_or_create_transpose1(
                &mut self,
                _input: root::taso::Tensor,
                permIdx: ::std::os::raw::c_int,
                _shuffle: bool,
            ) -> root::taso::Op {
                Model_get_or_create_transpose1(self, _input, permIdx, _shuffle)
            }
            #[inline]
            pub unsafe fn get_or_create_noop(
                &mut self,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op {
                Model_get_or_create_noop(self, _input, _type)
            }
            #[inline]
            pub unsafe fn get_or_create_merge_gconv(
                &mut self,
                _weight: *const root::taso::Tensor,
                count: ::std::os::raw::c_int,
            ) -> root::taso::Op {
                Model_get_or_create_merge_gconv(self, _weight, count)
            }
            #[inline]
            pub unsafe fn get_or_create_unsqueeze(
                &mut self,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> root::taso::Op {
                Model_get_or_create_unsqueeze(self, input, axes)
            }
            #[inline]
            pub unsafe fn get_or_create_where(
                &mut self,
                _cond: *const root::taso::Tensor,
                _x: *const root::taso::Tensor,
                _y: *const root::taso::Tensor,
            ) -> root::taso::Op {
                Model_get_or_create_where(self, _cond, _x, _y)
            }
            #[inline]
            pub unsafe fn create_input(
                &mut self,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op {
                Model_create_input(self, _input, _type)
            }
            #[inline]
            pub unsafe fn create_weight(
                &mut self,
                _weight: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op {
                Model_create_weight(self, _weight, _type)
            }
            #[inline]
            pub unsafe fn measure_conv2d_cost(&mut self, arg1: *mut root::taso::Conv2D) {
                Model_measure_conv2d_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_matmul_cost(&mut self, arg1: *mut root::taso::Matmul) {
                Model_measure_matmul_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_mul_cost(&mut self, arg1: *mut root::taso::Mul) {
                Model_measure_mul_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_pad_cost(&mut self, arg1: *mut root::taso::Pad) {
                Model_measure_pad_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_pool2d_cost(&mut self, arg1: *mut root::taso::Pool2D) {
                Model_measure_pool2d_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_topk_cost(&mut self, arg1: *mut root::taso::TopK) {
                Model_measure_topk_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_transpose_cost(&mut self, arg1: *mut root::taso::Transpose) {
                Model_measure_transpose_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_reduce_cost(&mut self, arg1: *mut root::taso::Reduce) {
                Model_measure_reduce_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_reshape_cost(&mut self, arg1: *mut root::taso::Reshape) {
                Model_measure_reshape_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_resize_cost(&mut self, arg1: *mut root::taso::Resize) {
                Model_measure_resize_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_activation_cost(&mut self, arg1: *mut root::taso::Activation) {
                Model_measure_activation_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_batchnorm_cost(&mut self, arg1: *mut root::taso::BatchNorm) {
                Model_measure_batchnorm_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_cast_cost(&mut self, arg1: *mut root::taso::Cast) {
                Model_measure_cast_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_concat_cost(&mut self, arg1: *mut root::taso::Concat) {
                Model_measure_concat_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_shape_cost(&mut self, arg1: *mut root::taso::Shape) {
                Model_measure_shape_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_slice_cost(&mut self, arg1: *mut root::taso::Slice) {
                Model_measure_slice_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_split_cost(&mut self, arg1: *mut root::taso::Split) {
                Model_measure_split_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_element_cost(&mut self, arg1: *mut root::taso::Element) {
                Model_measure_element_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_elementwise_unary_cost(
                &mut self,
                arg1: *mut root::taso::ElementWiseUnary,
            ) {
                Model_measure_elementwise_unary_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_enlarge_cost(&mut self, arg1: *mut root::taso::Enlarge) {
                Model_measure_enlarge_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_squeeze_cost(&mut self, arg1: *mut root::taso::Squeeze) {
                Model_measure_squeeze_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_unsqueeze_cost(&mut self, arg1: *mut root::taso::Unsqueeze) {
                Model_measure_unsqueeze_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_where_cost(&mut self, arg1: *mut root::taso::Where) {
                Model_measure_where_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn allocate_memory(
                &mut self,
                size: root::size_t,
                initial_data: *const root::taso::DATATYPE,
            ) -> *mut ::std::os::raw::c_void {
                Model_allocate_memory(self, size, initial_data)
            }
            #[inline]
            pub unsafe fn copy_memory(
                &mut self,
                dst: *mut root::taso::DATATYPE,
                src: *const root::taso::DATATYPE,
                size: root::size_t,
            ) -> bool {
                Model_copy_memory(self, dst, src, size)
            }
            #[inline]
            pub unsafe fn measure_oplist_runtime(&mut self, list: *const u8) -> f32 {
                Model_measure_oplist_runtime(self, list)
            }
            #[inline]
            pub unsafe fn broadcastable(
                &mut self,
                t1: *const root::taso::Tensor,
                t2: *const root::taso::Tensor,
            ) -> bool {
                Model_broadcastable(self, t1, t2)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Model_Model(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_ActivationKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_BatchNormKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_CastKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_ConcatKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_ConstantKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_Conv2DKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_ElementKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_ElementWiseUnaryKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_EnlargeKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_MatmulKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_MergeGConvKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_MulKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_NoopKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_PadKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_Pool2DKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_ReduceKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_ReshapeKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_ResizeKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_ShapeKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_SliceKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_SplitKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_SqueezeKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_TopKKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_TransposeKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_UnsqueezeKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_KeyCompare_open0_WhereKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::taso::KeyCompare>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::taso::KeyCompare)
            )
        );
    }
}
